#+TITLE: Raspberry Pi Baremetal Language Bootstrapping
#+AUTHOR: Robert Kovacsics (rmk35)

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+MACRO: cstart #+HTML:<table class="harmonica-table"><thead><tr><td>Assembly</td><td>Forth</td></tr></thead><tbody><tr><td>
#+MACRO: cmid #+HTML: </td><td>
#+MACRO: cend #+HTML: </td></tr></tbody></table>

#+PROPERTY: header-args:forth :eval no
#+OPTIONS: H:4

* COMMENT Prelude
#+BEGIN_SRC elisp
(setq asm-comment-char ?\@)
#+END_SRC

* Forth
** TODO A Jump-Threaded Interpreter
A piece of Forth code will look like the following, in memory:
#+BEGIN_SRC dot :file forth-jump-threaded-interpreter.png :cache yes
digraph {
  rankdir=LR;
  node [shape="record"];

  prog [label="<0> Forth interpreter | <1> Forth method | <2> Native method | ... | <n> Exit"];

  interp [label="<0> Push next_inst onto return stack | <1> Set next_inst from r0 | <n> Branch to `Next`"];

  subrA [label="<0> Forth interpreter | ... | <n> Exit"];
  subrB [label="<0> Native interpreter | <1> Instruction | ... | <n> Branch to `Next`"];
  subrExit [label="<0> Native interpreter | <1> Pop next_inst from return stack | <2> Branch to `Next`"];

  next [label="<0> Load next_inst to r0 | Increment next_inst | Load interpreter at r0 | Interpret r0+4"];

  prog:0 -> interp:0;
  subrA:0 -> interp:0;

  interp:n -> next:0;

  prog:1 -> subrA:0;
  prog:2 -> subrB:0;
  prog:n -> subrExit:0;

  subrA:n -> subrExit:0;

  subrB:0:e -> subrB:1:w;
  subrExit:0:e -> subrExit:1:w;
  subrB:n -> next:0;
  subrExit:2 -> next:0;
}
#+END_SRC

#+RESULTS[3a92227f044b51c3c226ed658cbd98f3f405fea2]:
[[file:forth-jump-threaded-interpreter.png]]

#+BEGIN_COMMENT
FWSIZE
#+END_COMMENT

Let's first look at the leftmost block, a forth code block, composed
of /forth words/, which may not be 32-bits (especially for systems
with small memory, but it is in this case). The first forth word of a
code block is always the interpreter, which here points to a native
code block that executes the rest of the forth words.

The forth interpreter pushes the ~next_inst~ onto the stack (like the
program counter, but for the interpreted words), loads the start of
the current code block from ~r0~ into ~next_inst~, and begins
executing the current code block by jumping to ~next~, another native code block

Of note here is the interpreter, which is how we differentiate between
Forth and native methods. For Forth methods, it pushes the
~next_instr~ onto the return stack; for native methods it is just a
pointer to the beginning of the assembled native code.

The Forth interpreter keeps executing the interpreters of each call in
the current method, including the exit call.

For code-blocks, we will be including both assembly code, and Forth
code (not standard, but will work once we have got to section TODO).

Until section [[sec:forth-assembly]] (or saying it before the code block),
all the assembly code goes into file ~stage0-machine-arm.s~.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
.macro fw word:req, rest:vararg
  .4byte \word /* FWSIZE */
  .ifnb \rest ; fw \rest ; .endif
.endm

  next_inst .req r11
  rsp .req r12

forth_interpreter:
  str next_inst, [rsp, #-4]!
  mov next_inst, r0
  /* b next */

next:
  ldr r0, [next_inst], #4 /* FWSIZE */
  ldr r1, [r0], #4 /* FWSIZE */
  bx r1

exit:
  ldr next_inst, [rsp], #4
  b next
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
:ASM FORTH-INTERPRETER
  { next_inst } return_stack PUSH
  r0 INTO next_inst MOV
  ( or next_inst FROM r0 MOV )
LABEL: NEXT
  next_inst INTO r0 2 LDRH+
  r0 INTO r1 4 LDR+ ( vs +LDR and +LDR! )
  r1 BX
:ASM EXIT
  TODO
#+END_SRC
{{{cend}}}

** DEBUG
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
tohex:
  cmp r0, #10
  addge r0, #'A'-10
  addlt r0, #'0'
  bx lr

puthex:
  push {r0-r4,lr}
  ror r2, r0, #28 /* 01 23 45 67 */
  mov r0, #'0' ; bl uart_putc
  mov r0, #'x' ; bl uart_putc
  mov r3, #15
  mov r4, #8
puthex_loop:
  and r0, r2, r3 ; bl tohex ; bl uart_putc
  ror r2, #28
  subs r4, #1
  bne puthex_loop
puthex_end:
  mov r0, #'\n' ; bl uart_putc
  pop {r0-r4,pc}
#+END_SRC

The exit call pops the previously saved ~next_instr~, then continuing
executing from there on by jumping to ~next~.

TODO: Have &ERR as the first thing on the return stack, so that when
we pop off one too many, it will be detected.

** TODO Dictionary-list
Next, we need to add the basic words (words being procedures, methods,
functions, or operators) of Forth, which we will need to implement
natively.

But before we implement those words, we need to make them findable by
the Forth system, for which we have to discuss the simple Forth
dictionary. The dictionary is a simple linked-list containing the
flags, name of the word, and the interpreter along with the code, as
discussed above.

#+BEGIN_SRC dot :file forth-dictionary.png :cache yes
digraph {
  rankdir=LR;
  node [shape="record"];

  DROP_XT [label="Drop XT", shape=none];
  DUP_XT [label="Dup XT", shape=none];
  DROP [label="<0> Next entry | Flags |Counted string\n\"DROP\\0\" | Padding | <xt> Interpreter | Code | ..."];
  DUP [label="<0> Next entry | Flags | Counted string\n\"DUP\\0\" | <xt> Interpreter | Code | ..."];

  LAST_ENTRY [label="End"];

  LATEST -> DROP:0
  DROP_XT -> DROP:xt
  DUP_XT -> DUP:xt
  DROP:0 -> DUP:0
  DUP:0 -> LAST_ENTRY
}
#+END_SRC

#+RESULTS[414409f65d09462df2bc5443a9c55f3713246576]:
[[file:forth-dictionary.png]]

Here a counted string means that the first element of the string is a
word (four bytes) containing the length of the string (in bytes),
which is followed by the bytes of the string, including a trailing
NULL byte, and padded to Forth-word boundary.

To help with making dictionary entries, we will need the following
macro, which creates the header for a dictionary entry. This includes
the next entry pointer, its flags, name, and finally an assembler
label to use with hand-written word implementations. But it doesn't
include the interpreter, so it can be used to create both native and
Forth words.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
.set previous_entry, 0
.macro entry name:req, label, imm=0, hid=0
.balign 4 /* Align to power of 2 */
1:fw previous_entry ; .set previous_entry, 1b
.byte \hid, \imm ; .balign 4
fw 2f-3f ; 3:.ascii "\name" ; 2: .byte 0
.balign 4 /* Align to power of 2 */
.ifc _,\label
.globl \name ; \name :
.else
.globl \label ; \label :
.endif
.endm
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: CREATE ( "<spaces>name" -- )
  here latest @ , latest !
  0 C, 0 C, align \ flags
  here cell-size allot
  bl word' \ addr start len
  nip 2dup swap ! \ addr len
  nip 1 + allot
  align ; \ padding
#+END_SRC
{{{cend}}}

*** Machine dependent words
The first dictionary entry is also the simplest. Remember that the
`entry' macro doesn't include the interpreter, so this just points to
the native code for exit, which pops the forth return stack and
continues executing from there.

#+BEGIN_SRC asm :tangle stage0-machine-arm.s
entry "EXIT", EXIT
  fw exit
#+END_SRC

To help define the rest of the machine-dependent words quicker, we
need a couple of macros first.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
.macro inst i, insts:vararg
  \i ; .ifnb \insts ; inst \insts ; .endif
.endm
.macro fasm1 name:req, label, pop, i:vararg
  entry \name, \label ; fw 1f
1: .ifnc _,\pop ; pop {\pop} ; .endif
  inst \i
.endm
.macro fasm name:req, label, pop, push, i:vararg
  fasm1 \name, \label, \pop, \i
  .ifnc _,\push ; push {\push} ; .endif
  b next
.endm

.macro binops name:req, label, op:req, rest:vararg
  fasm \name, \label, r0-r1, r1, "\op r1, r0"
  .ifnb \rest ; binops \rest ; .endif
.endm
.macro binrels name:req, label, rel:req, rest:vararg
  fasm1 \name, \label, r0-r1, "cmp r1, r0"
  mov r0, #0 ; mov\rel r0, #-1
  push {r0} ; b next
  .ifnb \rest ; binrels \rest ; .endif
.endm
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

We are now ready to define the basic Forth words in assembly, on top
of which we will build the rest of the Forth system. The ~EXIT~ we
have already defined above.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
binops "+", ADD, add,   "-", SUB, sub,   "*", STAR, mul
binops "LSHIFT", _, lsl,   "RSHIFT", _, lsr
binops "&", AND, and,   "|", OR, orr,    "XOR", _, eor

binrels "<>", NOT_EQUAL, ne,    "U<", U_LESS_THAN, lo
binrels "\x3d", EQUAL, eq,    "U>", U_GREATER_THAN, hi
binrels "<", LESS_THAN, lt,    ">", GREATER_THAN, gt

fasm "NEGATE", _, r0, r0, "rsb r0, #0"
fasm "INVERT", _, r0, r0, "mvn r0, r0"
fasm "C\x40", C_FETCH, r0, r0, "ldrB r0, [r0]"
fasm "\x40", FETCH, r0, r0, "ldr r0, [r0]" /* FWSIZE */
fasm "C!", C_STORE, r0-r1, _, "strB r1, [r0]"
fasm "!", STORE, r0-r1, _, "str r1, [r0]" /* FWSIZE */
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
fasm1 "BRANCH", _, _, "ldr r0, [next_inst]"
add next_inst, r0 ; b next /* FWSIZE */
fasm1 "?BRANCH", ZBRANCH, r1, "ldr r0, [next_inst]"
cmp r1, #0 ; addeq next_inst, r0 ; addne next_inst, #4
b next /* FWSIZE */
fasm "[\x27]", LIT, _, r0, "ldr r0, [next_inst], #4" /* FWSIZE */
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
fasm "CELL-SIZE", CELL_SIZE, _, r0, "mov r0, #4" /* CELLSIZE */
fasm "CHAR-SIZE", CHAR_SIZE, _, r0, "mov r0, #1" /* CHARSIZE */

fasm "NIP", _, r0-r1, r0
fasm "DROP", _, _, _, "add sp, #4" /* CELLSIZE */
fasm "DUP", _, _, r0, "ldr r0, [sp]"
fasm "OVER", _, _, r0, "ldr r0, [sp, #4]" /* CELLSIZE */
fasm "PICK", _, r0, r0, "ldr r0, [sp, r0, LSL #2]" /* CELLSIZE */
fasm "ROT", _, r0-r2, r2, "push {r0-r1}"
fasm "SWAP", _, r0-r1, r1,"push {r0}"

fasm "R\x40", R_FETCH, _, r0, "ldr r0, [rsp]" /* FWSIZE */
fasm "R>", R_FROM, _, r0, "ldr r0, [rsp], #4" /* FWSIZE */
fasm ">R", TO_R, r0, _, "str r0, [rsp, #-4]!" /* FWSIZE */
fasm "DEPTH", _, _, r0, "rsb r0, sp, #0x8000", "lsr r0, #2" /* FWSIZE */
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

There are also a couple of variables we need, this goes into a
different file (~vars.s~), so that the ~previous_entry~ points to the
latest defined Forth word.

{{{cstart}}}
#+BEGIN_SRC asm :tangle vars.s
.data
.balign 4
HERE_LOC: .4byte DATA_END
.globl previous_entry
LATEST_LOC:   .4byte previous_entry
STATE_LOC:    .4byte 0
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

We also need to implement functions for input/output.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
fasm "EMIT", _, r0, _, "bl uart_putc"
fasm "KEY", _, _, r0, "bl uart_getc", "bl uart_putc"
fasm "HEX.", HEX_PRINT, r0, _, "bl puthex"
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

*** TODO Simple helper words<<sec:forth-assembly>>
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
/* TODO: Use this more liberally */
.macro fdef name:req, label, rest:vararg
  entry \name, \label
  fw forth_interpreter
  fw \rest
.endm
#+END_SRC
{{{cmid}}}
{{{cend}}}

#+BEGIN_SRC asm :tangle stage0.s
fdef "1-", DECR, LIT, 1, SUB, EXIT
fdef "1+", INCR, LIT, 1, ADD, EXIT
fdef "2DUP", TWO_DUP, OVER, OVER, EXIT
fdef "2DROP", TWO_DROP, DROP, DROP, EXIT
fdef "-ROT", NROT, ROT, ROT, EXIT
fdef "2>R", TWO_TO_R, R_FROM, NROT, SWAP
fw TO_R, TO_R, TO_R, EXIT
fdef "2R>", TWO_R_FROM, R_FROM, R_FROM
fw R_FROM, ROT, TO_R, SWAP, EXIT
fdef "2RDROP", TWO_R_DROP, R_FROM, R_FROM
fw R_FROM, TWO_DROP, TO_R, EXIT
fdef "2R\x40", TWO_R_FETCH, R_FROM
fw TWO_R_FROM, TWO_DUP, TWO_TO_R, ROT
fw TO_R, EXIT
fdef "TRUE", _, LIT, -1, EXIT
fdef "FALSE", _, LIT, 0, EXIT
fdef "HERE_VAR", _, LIT, HERE_LOC, EXIT
fdef "LATEST", _, LIT, LATEST_LOC, EXIT
fdef "STATE", _, LIT, STATE_LOC, EXIT
fdef "HERE", _, HERE_VAR, FETCH, EXIT
fdef "CHAR+", CHAR_ADD, CHAR_SIZE, ADD, EXIT
fdef "CELL+", CELL_ADD, CELL_SIZE, ADD, EXIT
fdef "CHARS", _, CHAR_SIZE, STAR, EXIT
fdef "CELLS", _, CELL_SIZE, STAR, EXIT
fdef "C\x2c", C_COMMA, HERE, C_STORE, HERE
fw CHAR_ADD, HERE_VAR, STORE, EXIT
fdef "\x2c", COMMA, HERE, STORE, HERE
fw CELL_ADD, HERE_VAR, STORE, EXIT
#+END_SRC

*** TODO Creation
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "ALLOT", ALLOT
  fw forth_interpreter
  fw HERE, ADD, HERE_VAR, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: ALLOT HERE + HERE_VAR ! ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "ALIGN", ALIGN
  fw forth_interpreter
  fw HERE, CELL_SIZE, DECR, ADD
  fw CELL_SIZE, DECR, INVERT, AND
  fw HERE_VAR, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: ALIGN
  HERE 3 + 3 invert and
  HERE_VAR ! ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "CREATE", CREATE
  fw forth_interpreter
  fw HERE, LATEST, FETCH
  fw COMMA, LATEST, STORE
  fw LIT, 0, C_COMMA, LIT, 0, C_COMMA
  fw ALIGN, HERE, CELL_SIZE, ALLOT
  fw BL, WORD_NEW, NIP
  fw TWO_DUP, SWAP, STORE
  fw NIP, LIT, 1, ADD, ALLOT
  fw ALIGN
  fw LATEST, FETCH, COMMA, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: CREATE ( "<spaces>name" -- )
  here latest @ , latest !
  0 C, 0 C, align \ flags
  here cell-size allot
  bl word' \ addr start len
  nip 2dup swap ! \ addr len
  nip 1 + allot
  align ; \ padding
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
fdef "BALIGN", BALIGN, DECR, SWAP, OVER
fw ADD, SWAP, INVERT, AND, EXIT
fdef "ENTRY-NEXT", ENTRY_NEXT, EXIT
fdef "ENTRY-FLAGS", ENTRY_FLAGS, CELL_ADD, EXIT
fdef "ENTRY-LEN", ENTRY_LEN, LIT, 2
fw CELLS, ADD, EXIT
fdef "ENTRY-CHARS", ENTRY_CHARS, LIT, 3
fw CELLS, ADD, EXIT
fdef "ENTRY-XT", ENTRY_XT, DUP
fw ENTRY_LEN, FETCH, LIT, 1, ADD, SWAP
fw ENTRY_CHARS, ADD, LIT, 4, BALIGN, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}



{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "HIDDEN?", HIDDENP
  fw forth_interpreter
  fw ENTRY_FLAGS, C_FETCH, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: HIDDEN? entry-flags C@ ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "IMMEDIATE?", IMMEDIATEP
  fw forth_interpreter
  fw ENTRY_FLAGS, CHAR_ADD, C_FETCH, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: IMMEDIATE? ( xt -- -1|0 )
  entry-flags char+ C@ ;
#+END_SRC
{{{cend}}}

Toggles hidden status of a given xt

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "HIDE", HIDE
  fw forth_interpreter
  fw CELL_ADD, DUP, C_FETCH
  fw INVERT, SWAP, C_STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: HIDE ( xt -- )
  cell+ dup C@
  invert swap C! ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "IMMEDIATE", IMMEDIATE, -1
  fw forth_interpreter
  fw LATEST, FETCH
  fw TRUE, SWAP, CELL_ADD, CHAR_ADD, C_STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: IMMEDIATE ( -- )
  LATEST @
  true swap cell+ char+ C!
#+END_SRC
{{{cend}}}

*** TODO Lookup
- TODO :: Explain "c-addr u" and fwsize


{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "FIND'", FIND_NEW
  fw forth_interpreter
  fw LATEST, FETCH

FIND_LOOP: /* ( c-addr u entry ) */
  fw DUP, LIT, 0, EQUAL, ZBRANCH, (FIND_NON_END-.)
  fw DROP, DROP, LIT, 0, EXIT

FIND_NON_END:
  fw DUP, HIDDENP, INVERT
  fw ZBRANCH, (FIND_NEXT_ENTRY-.)

  fw TWO_DUP, ENTRY_LEN, FETCH, EQUAL
  fw ZBRANCH, (FIND_NEXT_ENTRY-.)
  /* c-addr u entry */
  fw TWO_DUP, ENTRY_CHARS
  fw LIT, 4, PICK
  /* c-addr u entry u entry-str c-addr */
  fw MEMCMP, ZBRANCH, (FIND_NEXT_ENTRY-.)

  fw NIP, NIP
  fw DUP, ENTRY_XT
  fw SWAP, IMMEDIATEP
  fw ZBRANCH, (NON_IMM-.), LIT, 1, BRANCH, (IMM_END-.)
NON_IMM:
  fw LIT, -1
IMM_END:
  fw EXIT

FIND_NEXT_ENTRY:
  fw FETCH
  fw BRANCH, (FIND_LOOP-.)
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: FIND' ( c-addr u -- c-addr 0 | xt 1 | xt -1 )
  latest @
  begin \ c-addr u entry
    dup 0 = if drop drop 0 exit then
    dup hidden? invert if
      2dup entry-len = if \ c-addr u entry entry-len u
        2dup entry-chars 4 pick
        \ c-addr u entry u entry-str c-addr
        memcmp if \ c-addr u entry
          nip nip \ entry
          dup entry-xt
          swap immediate? if 1 else -1 then
          exit
        then
      then
    then
    @ \ Fetch next entry
  again ;
#+END_SRC
{{{cend}}}

We also need to write the memory comparison, as well as the utilities
for the flags.

*** TODO Memory comparison
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "MEMCMP", MEMCMP
  fw forth_interpreter
  fw ROT, LIT, 0
  fw TWO_TO_R
MEMCMP_LOOP:
  fw TWO_DUP, R_FETCH, ADD, C_FETCH
  fw SWAP, R_FETCH, ADD, C_FETCH

  fw CHAR_EQUAL, INVERT, ZBRANCH, (MEMCMP_NEXT-.)
  fw TWO_R_DROP, TWO_DROP, FALSE, EXIT
MEMCMP_NEXT:
  fw R_FROM, LIT, 1, ADD, TO_R
  fw TWO_R_FETCH, EQUAL
  fw ZBRANCH, (MEMCMP_LOOP-.)
  fw TWO_R_DROP

  fw TWO_DROP, TRUE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: MEMCMP ( len a b -- true | false )
  rot 0 do
    2dup i + C@ swap i + C@
    = invert if unloop 2drop false exit then
  loop
  2drop true ;
#+END_SRC
{{{cend}}}

** TODO Input
*** Words
TODO: backspace (or perhaps with a modified key?)

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s asm :tangle stage0.s
entry "LOWER", LOWER
  fw forth_interpreter
  fw DUP, LIT, 'A', U_LESS_THAN
  fw OVER, LIT, 'Z', U_GREATER_THAN
  fw OR, INVERT, ZBRANCH, (1f-.)
  fw LIT, 32, ADD
1:fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: LOWER ( char -- char )
  dup char A U< over char Z U>
  or invert if 32 + then ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "CHAR=", CHAR_EQUAL
  fw forth_interpreter
  fw TWO_DUP, EQUAL, ZBRANCH, (1f-.)
  fw TWO_DROP, TRUE, EXIT
1:fw OVER, LIT, 33, U_LESS_THAN
  fw OVER, LIT, 33, U_LESS_THAN
  fw AND, ZBRANCH, (2f-.)
  fw TWO_DROP, TRUE, EXIT
2:fw LOWER, SWAP, LOWER, EQUAL
  fw ZBRANCH, (3f-.)
  fw TRUE, EXIT
3:fw FALSE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: CHAR=' ( char char -- -1|0 )
  2dup = if 2drop true exit then
  over 33 U< over 33 U< and if 2drop true exit then
  lower swap lower = if true exit then
  false ;
#+END_SRC
{{{cend}}}

TODO: transient region

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "WORD'", WORD_NEW
  fw forth_interpreter
  fw HERE, SWAP, LIT, 0
WORD_SKIP:
  fw DROP, KEY, TWO_DUP, CHAR_EQUAL
  fw INVERT, ZBRANCH, (WORD_SKIP-.)
WORD_LOOP:
  fw DUP, C_COMMA, OVER, CHAR_EQUAL
  fw ZBRANCH, (WORD_CONT-.)
  fw DROP, CHAR_SIZE, NEGATE, ALLOT
  fw HERE, OVER, SUB, LIT, 0, C_COMMA
  fw LIT, -1, OVER, SUB, ALLOT, EXIT
WORD_CONT:
  fw KEY, BRANCH, (WORD_LOOP-.)
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: WORD' ( char "<chars>ccc<char>" -- c-addr u )
  here swap
  0 begin drop key 2dup char= until
  begin \ start char key
    dup C,
    over char= if \ start char
      drop char-size negate allot
      here over - 0 C,
      -1 over - allot exit
    then
    key
  again ;
#+END_SRC
{{{cend}}}

*** Numbers
If the character is less than '0', or between '9' and 'A' (or 'Z' and
'a'), then it underflows, and will end up being greater than BASE.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "CHAR->DIGIT", CHAR_TO_DIGIT
  fw forth_interpreter
  fw LIT, '0', SUB
  fw DUP, LIT, 9, U_GREATER_THAN, ZBRANCH, (C_TO_D_END-.)
  fw LIT, ('A'-'9'-1), SUB
  fw DUP, LIT, 10, U_LESS_THAN, ZBRANCH, (C_TO_D_A-.)
  fw LIT, 10, SUB
C_TO_D_A:
  fw DUP, LIT, 35, U_GREATER_THAN, ZBRANCH, (C_TO_D_END-.)
  fw LIT, 32, SUB
  fw DUP, LIT, 10, U_LESS_THAN, ZBRANCH, (C_TO_D_END-.)
  fw LIT, 10, SUB
C_TO_D_END:
  fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: CHAR->DIGIT ( char -- digit )
  char 0 -
  dup 9 U> if
    7 - \ 9 : ; < = > ? @ A
    dup 10 U< if 10 - then
    dup 35 U> if
      32 - \ A-Z [ \ ] ^ _ ` a-z
      dup 10 U< if 10 - then
    then
  then ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.data
BASE_LOC: fw 10
.text
entry "BASE", BASE
  fw forth_interpreter
  fw LIT, BASE_LOC, EXIT
entry "DECIMAL", DECIMAL
  fw forth_interpreter
  fw LIT, 10, BASE, STORE, EXIT
entry ">NUMBER", TO_NUMBER
  fw forth_interpreter
  fw OVER, ADD, DUP, TO_R, SWAP
  fw TWO_TO_R
TO_NUM_LOOP:
  fw R_FETCH, C_FETCH, CHAR_TO_DIGIT, DUP
  fw BASE, FETCH, U_LESS_THAN
  fw ZBRANCH, (TO_NUM_ELSE-.)
  fw SWAP, BASE, FETCH, STAR, ADD
  fw BRANCH, (TO_NUM_NEXT-.)
TO_NUM_ELSE:
  fw DROP, R_FETCH, TWO_R_DROP, R_FROM
  fw OVER, SUB,  EXIT
TO_NUM_NEXT:
  fw R_FROM, LIT, 1, ADD, TO_R
  fw TWO_R_FETCH, EQUAL
  fw ZBRANCH, (TO_NUM_LOOP-.)
  fw TWO_R_DROP
  fw R_FROM, LIT, 0
  fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
variable BASE 10 BASE !
: >NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
  over + dup >R swap \ ud1 c-addr1+u1 c-addr1; R: c-addr1+u1
  do \ ud1; loops with  c-addr1 <= I < c-addr1+u1
    I C@ char->digit dup BASE @ U< if \ ud1 digit
      swap BASE @ * +
    else \ ud2 digit
      drop I unloop R> over - exit \ ud2 c-addr2 u2
    then
  loop
  R> 0 ;
#+END_SRC
{{{cend}}}

** TODO Interpreting
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
entry "EXECUTE", EXECUTE
  fw 1f
1:pop {r0}
  ldr r1, [r0], #4 /* FWSIZE */
  bx r1
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
:ASM EXECUTE-INTERPRETER
  { r0 } value_stack POP
  r1 r0 4 LDR+ \ TODO
  r0 BX ;
#+END_SRC
{{{cend}}}

** TODO Compiling
See §3.4 of the [[https://www.taygeta.com/forth/dpans3.htm#3.4][ANSI Forth manual]].

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "BL", BL
  fw forth_interpreter
  fw LIT, ' ', EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: BL ( -- char ) 32 ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "'", TICK
  fw forth_interpreter
  fw BL, WORD_NEW, FIND_NEW, DROP, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: TICK ( "<spaces>name" -- xt )
  bl word' find' drop ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "OK", OK
  fw forth_interpreter
  fw LIT, 'O', EMIT, LIT, 'k'
  fw EMIT, BL, EMIT, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: OK
  bl emit char O emit char k emit bl emit ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "ERROR", ERROR
  fw forth_interpreter
  fw LIT, 'E', EMIT, LIT, 'r', EMIT
  fw LIT, 'r', EMIT, BL, EMIT, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: ERROR
  char E emit char r emit char r emit bl emit ;
#+END_SRC
{{{cend}}}

** TODO REPL
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "COMPILE,", COMPILE_COMMA
  fw forth_interpreter
  fw COMMA, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "QUIT-FOUND", QUIT_FOUND
  fw forth_interpreter
  fw NIP, LIT, -1, EQUAL, STATE
  fw FETCH, AND, ZBRANCH, (Q_F_EX-.)
  fw COMPILE_COMMA, BRANCH, (Q_F_END-.)
Q_F_EX:
  fw EXECUTE
Q_F_END:
  fw OK, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: QUIT_FOUND ( xt u -1|1 -- )
  nip -1 = state @ and if \ Compiling
    compiling, else execute then
  ok ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "LITERAL", LITERAL, -1 /* immediate */
  fw forth_interpreter
  fw LIT, LIT, COMMA
  fw COMMA, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: LITERAL ( x -- )
  ' lit compiling, , ; \ TODO
: LITERAL ['] lit , ; IMMEDIATE
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "QUIT-NOT-FOUND", QUIT_NOT_FOUND
  fw forth_interpreter
  fw NROT, TO_NUMBER, LIT, 0
  fw EQUAL, ZBRANCH, (Q_N_F_ELSE-.)
  fw DROP, STATE, FETCH, ZBRANCH, (Q_N_F_END-.)
  fw LITERAL
  fw BRANCH, (Q_N_F_END-.)
Q_N_F_ELSE:
  fw TWO_DROP, ERROR, EXIT
Q_N_F_END:
  fw OK, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: QUIT_NOT_FOUND ( c-addr u 0 -- )
  rot rot >number 0 = if \ TODO negative numbers
    drop state @ if \ Compiling
      literal
    then
  else
    2drop error exit
  then
  ok ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "QUIT", QUIT
  fw forth_interpreter
QUIT_LOOP:
  fw BL, WORD_NEW, DUP, NROT
  fw FIND_NEW, ROT, SWAP
  fw DUP, ZBRANCH, (QUIT_N_F-.)
  fw QUIT_FOUND, BRANCH, (QUIT_LOOP-.)
QUIT_N_F:
  fw QUIT_NOT_FOUND, BRANCH, (QUIT_LOOP-.)
  fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: QUIT ( -- )
  \ TODO: Set up value and return stacks
  begin
    bl word' dup rot rot \ u c-addr u
    find' rot swap \ c-addr u -1|0|1
    dup if quit_found else
          quit_not_found then
    ok
  again ;
#+END_SRC
{{{cend}}}

** TODO Brave New Words
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "[", LBRAC,-1
  fw forth_interpreter
  fw LIT, 0, STATE, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: [ false state ! IMMEDIATE
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry "]", RBRAC
  fw forth_interpreter
  fw LIT, -1, STATE, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: ] true state !
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry ":", COLON
  fw forth_interpreter
  fw CREATE
  fw LIT, forth_interpreter, COMMA
  fw LATEST, FETCH, HIDE
  fw RBRAC, EXIT
  # TODO
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
entry ";", SEMICOLON, -1 /* immediate */
  fw forth_interpreter
  fw LIT, EXIT, COMMA
  fw LATEST, FETCH, HIDE, LBRAC, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

** TODO Control Words
TODO explain, especially as we don't have comments yet
- Note, not using compile, for [']
- Note, literal defined previously
  - But ['] and LITERAL are very similar
    - Can we use LIT as ['], it only needs compilation semantics?
      - Not quite, it doesn't push XT, it pushes entry->interpreter
        - Perhaps swap the meaning of XT back?
#+BEGIN_SRC forth
: POSTPONE ' compile, ; IMMEDIATE \ Can place elsewhere TODO
#+END_SRC

#+BEGIN_SRC forth
: ['] lit lit , ' , ; IMMEDIATE
: IF
  ['] ?BRANCH compile,
  HERE 0 , ; IMMEDIATE
: THEN
  HERE over - swap ! ; IMMEDIATE
: ELSE
  ['] BRANCH compile,
  HERE swap 0 ,
  HERE over - swap ! ; IMMEDIATE
#+END_SRC

#+BEGIN_SRC forth
TODO TO TEST

: BEGIN
  HERE ; IMMEDIATE
: AGAIN
  ['] BRANCH compile,
  HERE - , ; IMMEDIATE
: UNTIL
  ['] ?BRANCH compile,
  HERE - , ; IMMEDIATE
: WHILE
  ['] ?BRANCH compile,
  HERE swap 0 , ; IMMEDIATE
: REPEAT
  ['] BRANCH ,
  HERE swap - ,
  HERE over swap - swap ! ; IMMEDIATE
#+END_SRC

#+BEGIN_SRC forth
: DO
  2>R ; IMMEDIATE
: ?DO
  2dup <> ['] ?BRANCH compile, HERE
  2>R ; IMMEDIATE
: LOOP
  ;
: +LOOP
  ;
: LEAVE
  TODO ; IMMEDIATE
#+END_SRC

** TODO Comments
#+BEGIN_SRC forth
: CHAR word' drop C@ ;
: [CHAR] char literal ; IMMEDIATE
#+END_SRC

#+BEGIN_SRC forth
: \ begin key 10 = until ;
: ( begin key [char] ) = until ;
#+END_SRC

* TODO After REPL

* TODO Forth Assembler
* TODO Ideas
- Server and client :: Have the C implementation be a REPL server,
     with separate messages, errors, and stack buffers?
     - Support for up/downloading 'images' (the dictionary?), and
       perhaps replace raspbootin?
- DMA Forth :: Do [[cite:runDMA][run-DMA] TODO this link
- [[Naming][Naming]] :: All the stack manipulation could be simplified by having
            names.
- [[PRF][Partial Recursive Functions (PRF)]] :: Perhaps could take inspiration
     from the way composition is implemented there, in order to avoid
     all the stack manipulation? This could be more in the Forth
     spirit than [[Naming][naming]].
- Dereference-count :: When a pointer gets dereferenced a lot, move
     its pointee closer to that pointer (when doing mark&move GC)? To
     make it more likely to be in the cache (akin to
     simulated-annealing in the connection machine).
- Simple JIT :: Inline all the non-recursive calls?
- Debugger :: Breakpoints and tracing?
- Exception aspects :: To decouple the 'textbook algorithm' from exception handling?
- SD Card read/store :: So that we can compile to/read from disk, and don't have to

* TODO Naming
Plan is to extend forth to do naming, to make programs easier to
understand.

Doing this naively will probably result in a dynamic environment.

Something like
#+BEGIN_SRC forth
:fun REV-SUB ARG1 ARG2 => ARG2 ARG1 - ;
#+END_SRC
which could get turned into the equivalent of
#+BEGIN_SRC forth
: REV-SUB
  2 PUSH-STACK-FRAME
  2 FROM-FRAME
  1 FROM-FRAME
  -
  POP-FRAME
  ;
#+END_SRC
Also, I wonder if we need to redefine EXIT, for premature exits, or
perhaps have a trampoline take care of the push&pop, like so:
#+BEGIN_SRC asm
fw SETUP
fw P
fw TEARDOWN
fw EXIT
P:fw BODY, ...
#+END_SRC

This might even lead to optimisations, e.g. to
#+BEGIN_SRC forth
: REV-SUB
  SWAP -
  ;
#+END_SRC

And arg-count checking, possibly only at runtime first, to make sure
we don't return multiple values or get too few arguments. Possibly
static-checking too?

* TODO Partial Recursive Functions (PRF) <<PRF>>
Perhaps turn something like
#+BEGIN_SRC forth
\ FOO ( A B C -- V W )
\ BAR ( E F -- X )
\ BAZ ( V W X -- M N O )
{ FOO , , BAR } BAZ
#+END_SRC
into
#+BEGIN_SRC forth
FOO >R
>R \ from the empty
BAR >R
R> R> R>
BAZ
#+END_SRC
* COMMENT Table column
#+BEGIN_EXPORT html
<script type="text/javascript">
  function openTab(event) {
    let open_index = 0;
    for (let el of event.target.parentElement.children) {
      if (el === event.target)
        break;
      ++open_index;
    }
    let table = event.target.
        parentElement.parentElement.parentElement;
    for (let tbody of table.getElementsByTagName("tbody")) {
      for (let row of tbody.children) {
        let index = 0;
        for (let data of row.children) {
          if (index == open_index) {
            for (element of data.children)
              element.style.display =
                  element.style.display === "none" ?
                  "block" : "none";
          }
          ++index;
        }
      }
    }
  }

  for (let element of document.getElementsByClassName("harmonica-table")) {
    for (let theads of element.getElementsByTagName("thead")) {
      for (let row of theads.children) {
        let index = 0;
        for (let data of row.children) {
          data.addEventListener(
            "click", openTab);
        }
        ++index;
      }
    }
  }
</script>
#+END_EXPORT


* Bibliography
#+BIBLIOGRAHPY: pi-bootstrap plain
