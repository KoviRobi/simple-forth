#+TITLE: Raspberry Pi Baremetal Language Bootstrapping
#+AUTHOR: Robert Kovacsics (rmk35)

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+MACRO: cstart #+HTML:<table class="harmonica-table"><thead><tr><td>Assembly</td><td>Forth</td></tr></thead><tbody><tr><td>
#+MACRO: cmid #+HTML: </td><td>
#+MACRO: cend #+HTML: </td></tr></tbody></table>

#+PROPERTY: header-args:forth :eval no
#+OPTIONS: H:4

* COMMENT Prelude
#+BEGIN_SRC elisp
  (setq asm-comment-char ?\@)
#+END_SRC

* Forth
** A Jump-Threaded Interpreter
A piece of Forth code will look like the following, in memory:
#+BEGIN_SRC dot :file forth-jump-threaded-interpreter.png :cache yes
  digraph {
    rankdir=LR;
    node [shape="record"];

    prog [label="<0> Forth interpreter | <1> Forth method | <2> Native method | ... | <n> Exit"];

    interp [label="<0> Push next_inst onto return stack | <1> Set next_inst from r0 | <n> Branch to `Next`"];

    subrA [label="<0> Forth interpreter | ... | <n> Exit"];
    subrB [label="<0> Native interpreter | <1> Instruction | ... | <n> Branch to `Next`"];
    subrExit [label="<0> Native interpreter | <1> Pop next_inst from return stack | <2> Branch to `Next`"];

    next [label="<0> Load next_inst to r0 | Increment next_inst | Load interpreter at r0 | Interpret r0+4"];

    prog:0 -> interp:0;
    subrA:0 -> interp:0;

    interp:n -> next:0;

    prog:1 -> subrA:0;
    prog:2 -> subrB:0;
    prog:n -> subrExit:0;

    subrA:n -> subrExit:0;

    subrB:0:e -> subrB:1:w;
    subrExit:0:e -> subrExit:1:w;
    subrB:n -> next:0;
    subrExit:2 -> next:0;
  }
#+END_SRC

#+RESULTS[3a92227f044b51c3c226ed658cbd98f3f405fea2]:
[[file:forth-jump-threaded-interpreter.png]]

Let's first look at the leftmost block, a forth code block, composed
of /forth words/, which may not be 32-bits (especially for systems
with small memory). The first forth word of a code block is always the
interpreter, which here points to a native code block that executes
the rest of the forth words.

The forth interpreter pushes the ~next_inst~ onto the stack (like the
program counter, but for the interpreted words), loads the start of
the current code block from ~r0~ into ~next_inst~, and begins
executing the current code block by jumping to ~next~, another native code block

Of note here is the interpreter, which is how we differentiate between
Forth and native methods. For Forth methods, it pushes the
~next_instr~ onto the return stack; for native methods it is just a
pointer to the beginning of the assembled native code.

The Forth interpreter keeps executing the interpreters of each call in
the current method, including the exit call.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
    next_inst .req r11
    rsp .req r12

  forth_interpreter:
    str next_inst, [rsp], #-4
    mov next_inst, r0
    /* b next */

  next:
    ldrH r0, [next_inst], #2 /* FWSIZE */
    ldr r1, [r0], #4
    bx r1

  exit:  
    ldr next_inst, [rsp, #4]!
    b next
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  :ASM FORTH-INTERPRETER
    { next_inst } return_stack PUSH
    r0 INTO next_inst MOV
    ( or next_inst FROM r0 MOV )
  LABEL: NEXT
    next_inst INTO r0 2 LDRH+
    r0 INTO r1 4 LDR+ ( vs +LDR and +LDR! )
    r1 BX
  :ASM EXIT
    TODO
#+END_SRC
{{{cend}}}

The exit call pops the previously saved ~next_instr~, then continuing
executing from there on by jumping to ~next~.

TODO: Have &ERR as the first thing on the return stack, so that when
we pop off one too many, it will be detected.

** Dictionary-list
Next, we need to add the basic words (words being
procedures/methods/functions/operators) of Forth, which we will need
to implement natively.

But before we implement those words, we need to make them findable by
the Forth system, for which we have to discuss the simple Forth
dictionary. The dictionary is a simple linked-list containing the
flags, name of the word, a back-pointer (as the name is
variable-width), and the interpreter along with the code, as discussed
above.

#+BEGIN_SRC dot :file forth-dictionary.png :cache yes
  digraph {
    rankdir=LR;
    node [shape="record"];

    DROP_XT [label="Drop XT", shape=none];
    DUP_XT [label="Dup XT", shape=none];
    DROP [label="<0> Next entry | Flags |Counted string\n\"DROP\\0\" | Padding | <1> Back-pointer | <xt> Interpreter | Code | ..."];
    DUP [label="<0> Next entry | Flags | Counted string\n\"DUP\\0\" | <1> Back-pointer | <xt> Interpreter | Code | ..."];

    LAST_ENTRY [label="End"];

    LATEST -> DROP:0
    DROP_XT -> DROP:xt
    DROP:1:e -> DROP:0:w
    DUP_XT -> DUP:xt
    DROP:0 -> DUP:0
    DUP:1:e -> DUP:0:w
    DUP:0 -> LAST_ENTRY
  }
#+END_SRC

#+RESULTS[9f1017cd83564253a45c5d25ef89dda72a491f13]:
[[file:forth-dictionary.png]]

TODO: reword from here on

Here a counted string means that the first element of the string is a
word (four bytes) containing the length of the string (in bytes),
which is followed by the bytes of the string, including a trailing
NULL byte, and padded to forth-word boundary.

To help with making dictionary entries, we will need the following
macros. The right-hand column is the same assembly code, but in Forth,
so that we can have a reflective Forth interpreter.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
  .set previous_entry, 0
  .macro entry_header name:req, label:req, immediate=0, hidden=0
  .balign 4 /* Align to power of 2 */
  1:fw previous_entry
  .set previous_entry, 1b
  .byte \hidden
  .byte \immediate
  .balign 4
  fw 2f-3f
  3: .ascii "\name"; 2: .byte 0
  .balign 4 /* Align to power of 2 */
  fw 1b
  .globl \label
  \label :
  .endm
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : ENTRY-HEADER TODO FOO BAR BAZ ; IMMEDIATE
#+END_SRC
{{{cend}}}

*** Machine dependent words
We are now ready to define the basic Forth words in assembly, on top
of which we will build the rest of the Forth system.

- TODO :: Explain "c-addr u" and fwsize

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
  .macro fw word:req, rest:vararg
    .4byte \word
    .ifnb \rest; fw \rest; .endif
  .endm
  /* TODO: Use this more liberally */
  .macro fdef name:req, label:req, flags:req, rest:vararg
    entry_header \name, \label, \flags
    fw \rest
  .endm
#+END_SRC
{{{cmid}}}
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
  .macro binops name, label, op, rest:vararg
    entry_header \name, \label
    fw 1f
  1:pop {r0, r1}
    \op r1, r0
    push {r1}
    b next
    .ifnb \rest ; binops \rest ; .endif
  .endm

  .macro binrels name, label, rel, rest:vararg
    entry_header \name, \label
    fw 1f
  1:pop {r0, r1}
    cmp r1, r0
    mov r0, #0
    mov\rel r0, #-1
    push {r0}
    b next
    .ifnb \rest ; binrels \rest ; .endif
  .endm

  .macro unops name, label, op, rest:vararg
    entry_header \name, \label
    fw 1f
  1:pop {r0}
    \op r0
    push {r0}
    b next
    .ifnb \rest ; unops \rest ; .endif
  .endm
#+END_SRC
{{{cmid}}}
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
  entry_header "EXIT", EXIT
    fw 1f
  1:ldr next_inst, [rsp, #4]!
    b next

  binops "+", ADD, add,   "-", SUB, sub,   "*", STAR, mul
  binops "LSHIFT", LSHIFT, lsl,   "RSHIFT", RSHIFT, lsr
  binops "&", AND, and,   "|", OR, orr,    "XOR", XOR, eor
  binrels "<>", NOT_EQUAL, ne,    "U<", U_LESS_THAN, lo
  binrels "\x3d", EQUAL, eq,    "U>", U_GREATER_THAN, hi
  binrels "<", LESS_THAN, lt,    ">", GREATER_THAN, gt

  entry_header "NEGATE", NEGATE
    fw 1f
    pop {r0}
  1:rsb r0, #0
    push {r0}
    b next

  entry_header "INVERT", INVERT
    fw 1f
    pop {r0}
  1:mvn r0, r0
    push {r0}
    b next

  entry_header "C@", C_FETCH
    fw 1f
    pop {r0}
  1:ldrB r0, [r0] /* FWSIZE */
    push {r0}
    b next

  entry_header "C!", C_STORE
    fw 1f
    pop {r0-r1}
  1:strB r1, [r0] /* FWSIZE */
    b next

  entry_header "@", FETCH
    fw 1f
    pop {r0}
  1:ldrH r0, [r0] /* FWSIZE */
    push {r0}
    b next

  entry_header "!", STORE
    fw 1f
    pop {r0-r1}
  1:strH r1, [r0] /* FWSIZE */
    b next

  entry_header "BRANCH", BRANCH
    fw 1f
  1:ldrH r0, [next_inst] /* FWSIZE */
    add next_inst, r0
    b next

  entry_header "0BRANCH", ZBRANCH
    fw 1f
  1:pop {r1}
    ldrH r0, [next_inst] /* FWSIZE */
    cmp r1, #0
    addeq next_inst, r0
    addne next_inst, #2 /* FWSIZE */
    b next

  C_COMMA
  COMMA
  CELL
  CHAR

  HERE_VAR
  LATEST

  STATE
  TRUE
  FALSE
  LIT

  NIP
  DROP
  DUP
  OVER
  PICK
  ROT
  SWAP
  TWO_DROP
  TWO_DUP

  TWO_R_DROP
  TWO_R_FETCH
  R_FETCH
  R_FROM
  TO_R
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  :ASM EXIT
        next-inst rsp 4 true LDR
        next B ;
  :ASM +
        { 0 1 } value_stack POP
        r0 r1 ADD
        { 1 } value_stack PUSH ;
#+END_SRC
{{{cend}}}

*** Creation
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "HERE", HERE
    fw forth_interpreter
    fw HERE_VAR, FETCH, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : HERE HERE_VAR @ ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "ALLOT", ALLOT
    fw forth_interpreter
    fw HERE, ADD, HERE_VAR, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : ALLOT HERE + HERE_VAR ! ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "ALIGN", ALIGN
    fw forth_interpreter
    fw HERE, CELL_SIZE, DECR, ADD
    fw CELL_SIZE, DECR, INVERT, AND
    fw HERE_VAR, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : ALIGN
    HERE 3 + 3 invert and
    HERE_VAR ! ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "CREATE", CREATE
    fw forth_interpreter
    fw HERE, LATEST, FETCH
    fw COMMA, LATEST, STORE
    fw LIT, 0, C_COMMA, LIT, 0, C_COMMA
    fw ALIGN, HERE, CELL_SIZE, ALLOT
    fw BL, WORD_NEW, NIP
    fw TWO_DUP, SWAP, STORE
    fw NIP, LIT, 1, ADD, ALLOT
    fw ALIGN
    fw LATEST, FETCH, COMMA, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : CREATE ( "<spaces>name" -- )
    here latest @ , latest !
    0 C, 0 C, align \ flags
    here cell-size allot
    bl word' \ addr start len
    nip 2dup swap ! \ addr len
    nip 1 + allot
    align \ padding
    latest @ , ; \ back-pointer
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "CHAR+", CHAR_ADD
    fw forth_interpreter
    fw CHAR_SIZE, ADD, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : CHAR+ char-size + C@ ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "CELL+", CELL_ADD
    fw forth_interpreter
    fw CELL_SIZE, ADD, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : CELL+ cell-size + ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "HIDDEN?", HIDDENP
    fw forth_interpreter
    fw CELL_ADD, C_FETCH, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : HIDDEN? cell+ C@ ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "IMMEDIATE?", IMMEDIATEP
    fw forth_interpreter
    fw CELL_ADD, CHAR_ADD, C_FETCH, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : IMMEDIATE? ( xt -- -1|0 )
    cell+ char+ C@ ;
#+END_SRC
{{{cend}}}

Toggles hidden status of a given xt

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "HIDE", HIDE
    fw forth_interpreter
    fw CELL_ADD, DUP, C_FETCH
    fw INVERT, SWAP, C_STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : HIDE ( xt -- )
    cell+ dup C@
    invert swap C! ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "IMMEDIATE", IMMEDIATE, -1
    fw forth_interpreter
    fw LATEST, FETCH
    fw TRUE, SWAP, CELL_ADD, CHAR_ADD, C_STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : IMMEDIATE ( -- )
    LATEST @
    true swap cell+ char+ C!
#+END_SRC
{{{cend}}}

*** Lookup
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "FIND'", FIND_NEW
    fw forth_interpreter
    fw LATEST, FETCH

  FIND_LOOP: /* ( c-addr u entry ) */
    fw DUP, LIT, 0, EQUAL, ZBRANCH, (FIND_NON_END-.)
    fw DROP, DROP, LIT, 0, EXIT

  FIND_NON_END:
    fw DUP, HIDDENP, INVERT
    fw ZBRANCH, (FIND_NEXT_ENTRY-.)

    fw DUP, LIT, 8, ADD, FETCH, LIT, 2, PICK
    fw EQUAL, ZBRANCH, (FIND_NEXT_ENTRY-.)
    /* c-addr u entry */
    fw LIT, 1, PICK, LIT, 3, PICK
    fw LIT, 2, PICK, LIT, 12, ADD
    /* c-addr u entry u c-addr c-addr' */
    fw MEMCMP, ZBRANCH, (FIND_NEXT_ENTRY-.)

    fw NIP, NIP
    fw DUP, IMMEDIATEP
    fw ZBRANCH, (NON_IMM-.), LIT, 1, BRANCH, (IMM_END-.)
  NON_IMM:
    fw LIT, -1
  IMM_END:
    fw EXIT

  FIND_NEXT_ENTRY:
    fw FETCH
    fw BRANCH, (FIND_LOOP-.)
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : FIND' ( c-addr u -- c-addr 0 | xt 1 | xt -1 )
    latest @
    begin \ c-addr u entry
      dup 0 = if drop drop 0 exit then
      dup hidden? invert if
        dup 8 + @ 2 pick \ c-addr u entry entry-u u
        = if
          1 pick 3 pick 2 pick 12 +
          \ c-addr u entry u c-addr entry-str
          memcmp if \ c-addr u entry
            nip nip \ entry
            dup immediate? if 1 else -1 then
            exit
          then
        then
      then
      @ \ Fetch next entry
    again ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "ENTRY->INTERPRETER", ENTRY_TO_INTERPRETER
    fw forth_interpreter
    fw DUP, LIT, 8, ADD, FETCH, ADD, LIT, 12, ADD, LIT, 1, ADD
    fw LIT, 3, ADD, LIT, 3, INVERT, AND
    fw LIT, 4, ADD, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : ENTRY->INTERPRETER ( entry -- interpreter )
    dup 8 + @ + 12 + 1 + \ Skip over next entry, flags, c-string (and zero byte)
    3 + 3 invert and \ Align to power of 2 (multiple of 4)
    4 + ; \ Skip back-pointer
#+END_SRC
{{{cend}}}

We also need to write the memory comparison, as well as the utilities
for the flags.

*** Memory comparison
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "MEMCMP", MEMCMP
    fw forth_interpreter
    fw ROT, LIT, 0
    fw SWAP, TO_R, TO_R
  MEMCMP_LOOP:
    fw TWO_DUP, R_FETCH, ADD, C_FETCH
    fw SWAP, R_FETCH, ADD, C_FETCH

    fw CHAR_EQUAL, INVERT, ZBRANCH, (MEMCMP_NEXT-.)
    fw TWO_R_DROP, TWO_DROP, FALSE, EXIT
  MEMCMP_NEXT:
    fw R_FROM, LIT, 1, ADD, TO_R
    fw TWO_R_FETCH, EQUAL
    fw ZBRANCH, (MEMCMP_LOOP-.)
    fw TWO_R_DROP

    fw TWO_DROP, TRUE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : MEMCMP ( len a b -- true | false )
    rot 0 do
      2dup i + C@ swap i + C@
      = invert if unloop 2drop false exit then
    loop
    2drop true ;
#+END_SRC
{{{cend}}}

** Input
*** Characters
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
  UART1_MU_IO_REG:   fw 0x20215040
  UART1_MU_LSR_REG:  fw 0x20215054
  entry_header "KEY", KEY
    fw 1f
  1:ldr r0, #UART1_MU_LSR_REG
    ldr r0, [r0]
    tst r0, #1
    wfieq
    beq 1b
    ldr r0, #UART1_MU_IO_REG
    ldrB r0, [r0]
    b next
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  :ASM KEY TODO BUFFER FLOW CONTROL ;
#+END_SRC
{{{cend}}}

*** Words
TODO: backspace (or perhaps with a modified key?)

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s asm :tangle stage0.s
  entry_header "LOWER", LOWER
    fw forth_interpreter
    fw DUP, LIT, 'A', U_LESS_THAN
    fw OVER, LIT, 'Z', U_GREATER_THAN
    fw OR, INVERT, ZBRANCH, (1f-.)
    fw LIT, 32, ADD
  1:fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : LOWER ( char -- char )
    dup char A U< over char Z U>
    or invert if 32 + then ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "CHAR=", CHAR_EQUAL
    fw forth_interpreter
    fw TWO_DUP, EQUAL, ZBRANCH, (1f-.)
    fw TWO_DROP, TRUE, EXIT
  1:fw OVER, LIT, 33, U_LESS_THAN
    fw OVER, LIT, 33, U_LESS_THAN
    fw AND, ZBRANCH, (2f-.)
    fw TWO_DROP, TRUE, EXIT
  2:fw LOWER, SWAP, LOWER, EQUAL
    fw ZBRANCH, (3f-.)
    fw TRUE, EXIT
  3:fw FALSE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : CHAR=' ( char char -- -1|0 )
    2dup = if 2drop true exit then
    over 33 U< over 33 U< and if 2drop true exit then
    lower swap lower = if true exit then
    false ;
#+END_SRC
{{{cend}}}

TODO: transient region

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "WORD'", WORD_NEW
    fw forth_interpreter
    fw HERE, SWAP, LIT, 0
  WORD_SKIP:
    fw DROP, KEY, TWO_DUP, CHAR_EQUAL
    fw INVERT, ZBRANCH, (WORD_SKIP-.)
  WORD_LOOP:
    fw DUP, C_COMMA, OVER, CHAR_EQUAL
    fw ZBRANCH, (WORD_CONT-.)
    fw DROP, CHAR_SIZE, NEGATE, ALLOT
    fw HERE, OVER, SUB, LIT, 0, C_COMMA
    fw LIT, -1, OVER, SUB, ALLOT, EXIT
  WORD_CONT:
    fw KEY, BRANCH, (WORD_LOOP-.)
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : WORD' ( char "<chars>ccc<char>" -- c-addr u )
    here swap
    0 begin drop key 2dup char= until
    begin \ start char key
      dup C,
      over char= if \ start char
        drop char-size negate allot
        here over - 0 C,
        -1 over - allot exit
      then
      key
    again ;
#+END_SRC
{{{cend}}}

*** Numbers
If the character is less than '0', or between '9' and 'A' (or 'Z' and
'a'), then it underflows, and will end up being greater than BASE.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "CHAR->DIGIT", CHAR_TO_DIGIT
    fw forth_interpreter
    fw LIT, '0', SUB
    fw DUP, LIT, 9, U_GREATER_THAN, ZBRANCH, (C_TO_D_END-.)
    fw LIT, ('A'-'9'-1), SUB
    fw DUP, LIT, 10, U_LESS_THAN, ZBRANCH, (C_TO_D_A-.)
    fw LIT, 10, SUB
  C_TO_D_A:
    fw DUP, LIT, 35, U_GREATER_THAN, ZBRANCH, (C_TO_D_END-.)
    fw LIT, 32, SUB
    fw DUP, LIT, 10, U_LESS_THAN, ZBRANCH, (C_TO_D_END-.)
    fw LIT, 10, SUB
  C_TO_D_END:
    fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : CHAR->DIGIT ( char -- digit )
    char 0 -
    dup 9 U> if
      7 - \ 9 : ; < = > ? @ A
      dup 10 U< if 10 - then
      dup 35 U> if
        32 - \ A-Z [ \ ] ^ _ ` a-z
        dup 10 U< if 10 - then
      then
    then ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  .data
  BASE_VAR: fw 10
  .text
  entry_header "BASE", BASE
    fw forth_interpreter
    fw LIT, BASE_VAR, EXIT
  entry_header "DECIMAL", DECIMAL
    fw forth_interpreter
    fw LIT, 10, LIT, BASE_VAR, STORE, EXIT
  entry_header ">NUMBER", TO_NUMBER
    fw forth_interpreter
    fw OVER, ADD, DUP, TO_R, SWAP
    fw SWAP, TO_R, TO_R
  TO_NUM_LOOP:
    fw R_FETCH, C_FETCH, CHAR_TO_DIGIT, DUP
    fw BASE, FETCH, U_LESS_THAN
    fw ZBRANCH, (TO_NUM_ELSE-.)
    fw SWAP, BASE, FETCH, STAR, ADD
    fw BRANCH, (TO_NUM_NEXT-.)
  TO_NUM_ELSE:
    fw DROP, R_FETCH, TWO_R_DROP, R_FROM
    fw OVER, SUB, EXIT
  TO_NUM_NEXT:
    fw R_FROM, LIT, 1, ADD, TO_R
    fw TWO_R_FETCH, EQUAL
    fw ZBRANCH, (TO_NUM_LOOP-.)
    fw TWO_R_DROP
    fw R_FROM, LIT, 0
    fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  variable BASE 10 BASE !
  : >NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
    over + dup >R swap \ ud1 c-addr1+u1 c-addr1; R: c-addr1+u1
    do \ ud1; loops with  c-addr1 <= I < c-addr1+u1
      I C@ char->digit dup BASE @ U< if \ ud1 digit
        swap BASE @ * +
      else \ ud1
        drop I unloop R> over - exit \ ud2 c-addr2 u2
      then
    loop
    R> 0 ;
#+END_SRC
{{{cend}}}

** Output
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
  entry_header "EMIT", EMIT
    fw 1f
  1:ldr r1, #UART1_MU_LSR_REG
    ldr r1, [r1]
    tst r1, #32
    wfieq
    beq 1b
    ldr r1, #UART1_MU_IO_REG
    strB r0, [r1]
    b next
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

** Interpreting
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
  entry_header "EXECUTE-INTERPRETER", EXECUTE_INTERPRETER
    fw 1f
  1:pop {r0}
    ldr r0, [r0] // TODO: don't we want ldr r1, [r0], #4
    ldr r1, [r0], #4 \\ TODO: ldr r1, [r1]
    bx r1
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  :ASM EXECUTE-INTERPRETER
    { r0 } value_stack POP
    r1 r0 4 LDR+ \ TODO
    r0 BX ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "EXECUTE", EXECUTE
    fw forth_interpreter
    fw ENTRY_TO_INTERPRETER
    fw EXECUTE_INTERPRETER, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : EXECUTE
    entry->interpreter execute-interpreter ;
#+END_SRC
{{{cend}}}

** Compiling
See §3.4 of the [[https://www.taygeta.com/forth/dpans3.htm#3.4][ANSI Forth manual]].

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "BL", BL
    fw forth_interpreter
    fw LIT, ' ', EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : BL ( -- char )
    32 ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "'", TICK
    fw forth_interpreter
    fw BL, WORD_NEW, FIND_NEW, DROP, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : TICK ( "<spaces>name" -- xt )
    bl word' find' drop ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "OK", OK
    fw forth_interpreter
    fw LIT, 'O', EMIT, LIT, 'k'
    fw EMIT, BL, EMIT, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : OK
    bl emit char O emit char k emit bl emit ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "ERROR", ERROR
    fw forth_interpreter
    fw LIT, 'E', EMIT, LIT, 'r', EMIT
    fw LIT, 'r', EMIT, BL, EMIT, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : ERROR
    char E emit char r emit char r emit bl emit ;
#+END_SRC
{{{cend}}}

** REPL
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "COMPILE,", COMPILE_COMMA
    fw forth_interpreter
    fw ENTRY_TO_INTERPRETER
    fw COMMA, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : COMPILING, ( xt -- )
    nip -1 = state @ and if \ Compiling
      compiling, else execute then
    ok ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "QUIT-FOUND", QUIT_FOUND
    fw forth_interpreter
    fw NIP, LIT, -1, EQUAL, STATE
    fw FETCH, AND, ZBRANCH, (Q_F_EX-.)
    fw COMPILE_COMMA, BRANCH, (Q_F_END-.)
  Q_F_EX:
    fw EXECUTE
  Q_F_END:
    fw OK, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : QUIT_FOUND ( xt u -1|1 -- )
    nip -1 = state @ and if \ Compiling
      compiling, else execute then
    ok ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "LITERAL", LITERAL, -1 /* immediate */
    fw forth_interpreter
    fw LIT, LIT, COMMA
    fw COMMA, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : LITERAL ( x -- )
    ' lit compiling, , ; \ TODO
  : LITERAL ['] lit , ; IMMEDIATE
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "QUIT-NOT-FOUND", QUIT_NOT_FOUND
    fw forth_interpreter
    fw ROT, ROT, TO_NUMBER, LIT, 0
    fw EQUAL, ZBRANCH, (Q_N_F_ELSE-.)
    fw DROP, STATE, FETCH, ZBRANCH, (Q_N_F_END-.)
    fw LITERAL
    fw BRANCH, (Q_N_F_END-.)
  Q_N_F_ELSE:
    fw TWO_DROP, ERROR, EXIT
  Q_N_F_END:
    fw OK, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : QUIT_NOT_FOUND ( c-addr u 0 -- )
    rot rot >number 0 = if \ TODO negative numbers
      drop state @ if \ Compiling
        literal
      then
    else
      2drop error exit
    then
    ok ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "QUIT", QUIT
    fw forth_interpreter
  QUIT_LOOP:
    fw BL, WORD_NEW, DUP, ROT, ROT
    fw FIND_NEW, ROT, SWAP
    fw DUP, ZBRANCH, (QUIT_N_F-.)
    fw QUIT_FOUND, BRANCH, (QUIT_LOOP-.)
  QUIT_N_F:
    fw QUIT_NOT_FOUND, BRANCH, (QUIT_LOOP-.)
    fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : QUIT ( -- )
    \ TODO: Set up value and return stacks
    begin
      bl word' dup rot rot \ u c-addr u
      find' rot swap \ c-addr u -1|0|1
      dup if quit_found else
            quit_not_found then
      ok
    again ;
#+END_SRC
{{{cend}}}

** Brave New Words
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "[", LBRAC,-1
    fw forth_interpreter
    fw LIT, 0, STATE, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : [ false state ! IMMEDIATE
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header "]", RBRAC
    fw forth_interpreter
    fw LIT, -1, STATE, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
  : ] true state !
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header ":", COLON
    fw forth_interpreter
    fw CREATE
    fw LIT, forth_interpreter, COMMA
    fw LATEST, FETCH, HIDE
    fw RBRAC, EXIT
    # TODO
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
  entry_header ";", SEMICOLON, -1 /* immediate */
    fw forth_interpreter
    fw LIT, EXIT, COMMA
    fw LATEST, FETCH, HIDE, LBRAC, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
    TODO
#+END_SRC
{{{cend}}}

** Control Words
TODO explain, especially as we don't have comments yet
- Note, not using compile, for [']
- Note, literal defined previously
  - But ['] and LITERAL are very similar
    - Can we use LIT as ['], it only needs compilation semantics?
      - Not quite, it doesn't push XT, it pushes entry->interpreter
        - Perhaps swap the meaning of XT back?
#+BEGIN_SRC forth
  : POSTPONE ' compile, ; IMMEDIATE \ Can place elsewhere TODO
  #+END_SRC

  #+BEGIN_SRC forth
  : ['] lit lit , ' , ; IMMEDIATE
  : IF
    ['] 0BRANCH compile,
    HERE 0 , ; IMMEDIATE
  : THEN
    HERE over - swap ! ; IMMEDIATE
  : ELSE
    ['] BRANCH compile,
    HERE swap 0 ,
    HERE over - swap ! ; IMMEDIATE
#+END_SRC

#+BEGIN_SRC forth
  TODO TO TEST

  : BEGIN
    HERE ; IMMEDIATE
  : AGAIN
    ['] BRANCH compile,
    HERE - , ; IMMEDIATE
  : UNTIL
    ['] 0BRANCH compile,
    HERE - , ; IMMEDIATE
  : WHILE
    ['] 0BRANCH compile,
    HERE swap 0 , ; IMMEDIATE
  : REPEAT
    ['] BRANCH ,
    HERE swap - ,
    HERE over swap - swap ! ; IMMEDIATE
#+END_SRC

#+BEGIN_SRC forth
  : DO
    2>R ; IMMEDIATE
  : ?DO
    2dup <> ['] 0BRANCH compile, HERE
    2>R ; IMMEDIATE
  : LOOP
    ;
  : +LOOP
    ;
  : LEAVE
    TODO ; IMMEDIATE
#+END_SRC

** Comments
#+BEGIN_SRC forth
  : CHAR word' drop C@ ;
  : [CHAR] char literal ; IMMEDIATE
  #+END_SRC

  #+BEGIN_SRC forth
  : \ begin key 10 = until ;
  : ( begin key [char] ) = until ;
#+END_SRC

* After REPL
* Naming
Plan is to extend forth to do naming, to make programs easier to
understand.

Doing this naively will probably result in a dynamic environment.

Something like
#+BEGIN_SRC forth
  :fun REV-SUB ARG1 ARG2 => ARG2 ARG1 - ;
#+END_SRC
which could get turned into the equivalent of
#+BEGIN_SRC forth
  : REV-SUB
    2 PUSH-STACK-FRAME
    2 FROM-FRAME
    1 FROM-FRAME
    -
    POP-FRAME
    ;
#+END_SRC
Also, I wonder if we need to redefine EXIT, for premature exits, or
perhaps have a trampoline take care of the push&pop, like so:
#+BEGIN_SRC asm
  fw SETUP
  fw P
  fw TEARDOWN
  fw EXIT
  P:fw BODY, ...
#+END_SRC

This might even lead to optimisations, e.g. to
#+BEGIN_SRC forth
  : REV-SUB
    SWAP -
    ;
#+END_SRC

And arg-count checking, possibly only at runtime first, to make sure
we don't return multiple values or get too few arguments. Possibly
static-checking too?

* Ideas
- Dereference-count :: When a pointer gets dereferenced a lot, move
     its pointee closer to that pointer (when doing mark&move GC)?
- Simple JIT :: Inline all the non-recursive calls?
- Debugger :: Breakpoints and tracing?
- Exception aspects :: To decouple the 'textbook algorithm' from exception handling?
- SD Card read/store :: So that we can compile to/read from disk, and don't have to



#+BEGIN_EXPORT html
<script type="text/javascript">
  function openTab(event) {
    let open_index = 0;
    for (let el of event.target.parentElement.children) {
      if (el === event.target)
        break;
      ++open_index;
    }
    let table = event.target.
        parentElement.parentElement.parentElement;
    for (let tbody of table.getElementsByTagName("tbody")) {
      for (let row of tbody.children) {
        let index = 0;
        for (let data of row.children) {
          if (index == open_index) {
            for (element of data.children)
              element.style.display =
                  element.style.display === "none" ?
                  "block" : "none";
          }
          ++index;
        }
      }
    }
  }

  for (let element of document.getElementsByClassName("harmonica-table")) {
    for (let theads of element.getElementsByTagName("thead")) {
      for (let row of theads.children) {
        let index = 0;
        for (let data of row.children) {
          data.addEventListener(
            "click", openTab);
        }
        ++index;
      }
    }
  }
</script>
#+END_EXPORT

