#+TITLE: Raspberry Pi Baremetal Language Bootstrapping
#+AUTHOR: Robert Kovacsics (rmk35)

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>

#+MACRO: cstart #+HTML:<table class="harmonica-table"><thead><tr><td>Assembly</td><td>Forth</td></tr></thead><tbody><tr><td>
#+MACRO: cmid #+HTML: </td><td>
#+MACRO: cend #+HTML: </td></tr></tbody></table>

#+PROPERTY: header-args:forth :eval no
#+OPTIONS: H:4

* COMMENT Prelude
#+BEGIN_SRC elisp
(setq asm-comment-char ?\@)
#+END_SRC

* TODO Forth
** TODO The base interpreter
There are multiple choices of interpreters, each with their own
advantages and disadvantages.

*** TODO An Indirect-Threaded Interpreter
A piece of Forth code will look like the following, in memory:
#+BEGIN_SRC dot :file forth-jump-threaded-interpreter.png :cache yes
digraph {
  rankdir=TB;
  node [shape="record"];

  prog [label="<0> Forth\ninterpreter | <1> Address of Forth method | <2> Address of Native method | ... | <n> Exit"];

  interp [label="<0> Push next_inst\nonto return stack | <1> Set next_inst\nfrom r0 | <n> Branch to `Next`"];

  subrA [label="<0> Forth\ninterpreter | ... | <n> Exit"];
  subrB [label="<0> Next\ncell | <1> Instruction | ... | <n> Branch to\n`Next`"];
  subrExit [label="<0> Next\ncell | <1> Pop next_inst\nfrom return stack | <2> Branch to\n`Next`"];

  next [label="<0> Load next_inst to r0 | Increment next_inst | Load interpreter at r0 | Interpret r0+4"];

  prog:0 -> interp:0;
  subrA:0 -> interp:0 [minlen=2];

  interp:0:s -> next:0:n [color=white,minlen=2];
  interp:n:s -> next:0:n [constraint=false];

  prog:1 -> subrA:0:n [minlen=2];
  prog:2 -> subrB:0:n [minlen=2];
  prog:n:s -> subrExit:0;

  subrA:n:s -> subrExit:0 [minlen=2];

  subrB:0:n -> subrB:1:n;
  subrExit:0:n -> subrExit:1:n;
  subrB:n:s -> next:0:n [constraint=false];
  subrExit:2:s -> next:0:n [constraint=false];
}
#+END_SRC

#+RESULTS[f99a82b51e953c459dbfdfa274f4577c67ddd2e6]:
[[file:forth-jump-threaded-interpreter.png]]

#+BEGIN_COMMENT
FWSIZE
#+END_COMMENT

Let's first look at the leftmost block, a forth code block, composed
of /forth words/, which may not be 32-bits (especially for systems
with small memory, but it is in this case). The first forth word of a
code block is always the interpreter, which here points to a native
code block that executes the rest of the forth words.

The forth interpreter pushes the ~next_inst~ onto the stack (like the
program counter, but for the interpreted words), loads the start of
the current code block from ~r0~ into ~next_inst~, and begins
executing the current code block by jumping to ~next~, another native code block

Of note here is the interpreter, which is how we differentiate between
Forth and native methods. For Forth methods, it pushes the
~next_instr~ onto the return stack; for native methods it is just a
pointer to the beginning of the assembled native code.

The Forth interpreter keeps executing the interpreters of each call in
the current method, including the exit call.

For code-blocks, we will be including both assembly code, and Forth
code (not standard, but will work once we have got to section TODO).

Until section [[sec:forth-assembly]] (or saying it before the code block),
all the assembly code goes into file ~stage0-machine-arm.s~.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-indirect-threaded-arm.s
next_inst .req r11
data_space .req r11
rsp .req r12

.macro .execute reg=r0
  ldr pc, [\reg], #4 /* FWSIZE */
.endm
.macro .next
  b next
.endm
.macro .exit
  ldr next_inst, [rsp], #4
  b next
.endm
.macro .fw word:req, rest:vararg
  .4byte \word /* FWSIZE */
  .ifnb \rest ; .fw \rest ; .endif
.endm
.macro .forth_interpreter
  .fw forth_interpreter
.endm
.macro .asm_interpreter
  .fw 1f
1:
.endm
.macro .cell init=0
  .word \init
.endm

forth_interpreter:
  str next_inst, [rsp, #-4]!
  mov next_inst, r0
  /* b next */

next:
  ldr r0, [next_inst], #4 /* FWSIZE */
  .execute
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
:ASM FORTH-INTERPRETER
  { next_inst } return_stack PUSH
  r0 INTO next_inst MOV
  ( or next_inst FROM r0 MOV )
LABEL: NEXT
  next_inst INTO r0 2 LDRH+
  r0 INTO r1 4 LDR+ ( vs +LDR and +LDR! )
  r1 BX
:ASM EXIT
  TODO
#+END_SRC
{{{cend}}}

*** TODO A Direct-Threaded Interpreter
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-direct-threaded-arm.s
next_inst .req r11
data_space .req r11
rsp .req r12

.macro .execute reg=r0
  bx \reg
.endm
.macro .next
  ldr pc, [next_inst], #4 /* FWSIZE */
.endm
.macro .exit
  ldr next_inst, [rsp], #4
  .next
.endm
.macro .fw word:req, rest:vararg
  .4byte \word /* FWSIZE */
  .ifnb \rest ; .fw \rest ; .endif
.endm
.macro .forth_interpreter
  bl forth_interpreter
.endm
.macro .asm_interpreter
.endm
.macro .cell init=0
  .word \init
.endm

forth_interpreter:
  str next_inst, [rsp, #-4]!
  mov next_inst, lr
  .next
#+END_SRC
{{{cmid}}}
{{{cend}}}

*** TODO A Subroutine-Threaded Interpreter
**** Arm32
Anything that calls a subroutine should save LR
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-subroutine-threaded-arm.s
next_inst .req lr
rsp .req r12

.macro .execute reg=r0
  bx \reg
.endm
.macro .next
  bx lr
.endm
.macro .exit
  // This is rsp+4 because EXIT (implemented as asm) doesn't
  // push its LR to RSP
  ldr pc, [rsp], #4
.endm
.macro .fw word:req, rest:vararg
  .ifc "\word","L"
    .cellw \rest
  .else
    bl \word /* FWSIZE */
    .ifnb \rest ; .fw \rest ; .endif
  .endif
.endm
.macro .cellw n:req, rest:vararg
  .cell \n
  .ifnb \rest ; .fw \rest ; .endif
.endm
.macro .forth_interpreter
  /*push {lr}
  mov r0, #'\t'
  bl uart_putc
  mov r0, #'-'
  rsb r2, rsp, #0x4000
  1: bl uart_putc
  subs r2, r2, #1
  bcs 1b
  mov r0, #' '
  bl uart_putc
  mov r0, pc
  bl puthex
  pop {lr}*/
  str lr, [rsp, #-4]!
.endm
.macro .asm_interpreter
  /*push {lr}
  mov r0, #'\t'
  bl uart_putc
  mov r0, #'-'
  rsb r2, rsp, #0x4000
  1: bl uart_putc
  subs r2, r2, #1
  bcs 1b
  mov r0, #' '
  bl uart_putc
  mov r0, pc
  bl puthex
  pop {lr}*/
.endm
.macro .cell init=0
  .word \init
.endm
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
:ASM FORTH-INTERPRETER
  { next_inst } return_stack PUSH
  r0 INTO next_inst MOV
  ( or next_inst FROM r0 MOV )
LABEL: NEXT
  next_inst INTO r0 2 LDRH+
  r0 INTO r1 4 LDR+ ( vs +LDR and +LDR! )
  r1 BX
:ASM EXIT
  TODO
#+END_SRC
{{{cend}}}

**** Thumb
** DEBUG
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
tohex:
  cmp r0, #10
  addge r0, #'A'-10
  addlt r0, #'0'
  bx lr

puthex:
  push {r0-r4,lr}
  ror r2, r0, #28 /* 01 23 45 67 */
  mov r0, #'0' ; bl uart_putc
  mov r0, #'x' ; bl uart_putc
  mov r3, #15
  mov r4, #8
puthex_loop:
  and r0, r2, r3 ; bl tohex ; bl uart_putc
  ror r2, #28
  subs r4, #1
  bne puthex_loop
puthex_end:
  mov r0, #'\n' ; bl uart_putc
  pop {r0-r4,pc}
#+END_SRC

The exit call pops the previously saved ~next_instr~, then continuing
executing from there on by jumping to ~next~.

TODO: Have &ERR as the first thing on the return stack, so that when
we pop off one too many, it will be detected.

** TODO Dictionary-list
Next, we need to add the basic words (words being procedures, methods,
functions, or operators) of Forth, which we will need to implement
natively.

But before we implement those words, we need to make them findable by
the Forth system, for which we have to discuss the simple Forth
dictionary. The dictionary is a simple linked-list containing the
flags, name of the word, and the interpreter along with the code, as
discussed above.

#+BEGIN_SRC dot :file forth-dictionary.png :cache yes
digraph {
  rankdir=LR;
  node [shape="record"];

  DROP_XT [label="Drop XT", shape=none];
  DUP_XT [label="Dup XT", shape=none];
  DROP [label="<0> Next entry | Flags |Counted string\n\"DROP\\0\" | Padding | <xt> Interpreter | Code | ..."];
  DUP [label="<0> Next entry | Flags | Counted string\n\"DUP\\0\" | <xt> Interpreter | Code | ..."];

  LAST_ENTRY [label="End"];

  LATEST -> DROP:0
  DROP_XT -> DROP:xt
  DUP_XT -> DUP:xt
  DROP:0 -> DUP:0
  DUP:0 -> LAST_ENTRY
}
#+END_SRC

#+RESULTS[414409f65d09462df2bc5443a9c55f3713246576]:
[[file:forth-dictionary.png]]

Here a counted string means that the first element of the string is a
word (four bytes) containing the length of the string (in bytes),
which is followed by the bytes of the string, including a trailing
NULL byte, and padded to Forth-word boundary.

To help with making dictionary entries, we will need the following
macro, which creates the header for a dictionary entry. This includes
the next entry pointer, its flags, name, and finally an assembler
label to use with hand-written word implementations. But it doesn't
include the interpreter, so it can be used to create both native and
Forth words.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
.set previous_entry, 0
.macro .entry name:req, label, imm=0, hid=0
.balign 4 /* Align to power of 2 */
1:.cell previous_entry ; .set previous_entry, 1b
.byte \hid, \imm ; .balign 4
.cell 2f-3f ; 3:.ascii "\name" ; 2: .byte 0
.balign 4 /* Align to power of 2 */
.ifc _,\label
.globl \name ; \name :
.else
.globl \label ; \label :
.endif
.endm
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: CREATE ( "<spaces>name" -- )
  align
  here latest @ , latest !
  0 C, 0 C, align \ flags
  here cell-size allot
  bl word' \ addr start len
  nip 2dup swap ! \ addr len
  nip 1 + allot
  align ; \ padding
#+END_SRC
{{{cend}}}

*** Machine dependent words
The first dictionary entry is also the simplest. Remember that the
`entry' macro doesn't include the interpreter, so this just points to
the native code for exit, which pops the forth return stack and
continues executing from there.

#+BEGIN_SRC asm :tangle stage0-machine-arm.s
.entry EXIT, _
.asm_interpreter
.exit
#+END_SRC

To help define the rest of the machine-dependent words quicker, we
need a couple of macros first.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
.macro .insts i, insts:vararg
  \i ; .ifnb \insts ; .insts \insts ; .endif
.endm
.macro .fasm1 name:req, label, pop, i:vararg
  .entry \name, \label
  .asm_interpreter
  .ifnc _,\pop ; pop {\pop} ; .endif
  .insts \i
.endm
.macro .fasm name:req, label, pop, push, i:vararg
  .fasm1 \name, \label, \pop, \i
  .ifnc _,\push ; push {\push} ; .endif
  .next
.endm

.macro .binops name:req, label, op:req, rest:vararg
  .fasm \name, \label, r0-r1, r1, "\op r1, r0"
  .ifnb \rest ; .binops \rest ; .endif
.endm
.macro .binrels name:req, label, rel:req, rest:vararg
  .fasm1 \name, \label, r0-r1, "cmp r1, r0"
  mov r0, #0 ; mov\rel r0, #-1
  push {r0} ; .next
  .ifnb \rest ; .binrels \rest ; .endif
.endm
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

We are now ready to define the basic Forth words in assembly, on top
of which we will build the rest of the Forth system. The ~EXIT~ we
have already defined above.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
.binops "+", ADD, add,   "-", SUB, sub,   "*", STAR, mul
.binops "LSHIFT", _, lsl,   "RSHIFT", _, lsr
.binops "&", AND, and,   "|", OR, orr,    "XOR", _, eor

.binrels "<>", NOT_EQUAL, ne,    "U<", U_LESS_THAN, lo
.binrels "\x3d", EQUAL, eq,    "U>", U_GREATER_THAN, hi
.binrels "<", LESS_THAN, lt,    ">", GREATER_THAN, gt

.fasm "NEGATE", _, r0, r0, "rsb r0, #0"
.fasm "INVERT", _, r0, r0, "mvn r0, r0"
.fasm "C\x40", C_FETCH, r0, r0, "ldrB r0, [r0]"
.fasm "\x40", FETCH, r0, r0, "ldr r0, [r0]" /* FWSIZE */
.fasm "C!", C_STORE, r0-r1, _, "strB r1, [r0]"
.fasm "!", STORE, r0-r1, _, "str r1, [r0]" /* FWSIZE */
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

TODO: Separate vs contiguous data-space (in case icache and dcache
coherency extends to reads, not just writes)

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
//  TODO: SUBROUTINE .fasm1 "(BRANCH)", BRANCH, _, "ldr r0, [data_space]"
//  TODO: SUBROUTINE add next_inst, r0 ; .next /* FWSIZE */
//  TODO: SUBROUTINE .fasm1 "(?BRANCH)", ZBRANCH, r1, "ldr r0, [data_space]"
//  TODO: SUBROUTINE cmp r1, #0 ; addeq next_inst, r0 ; addne next_inst, #4
//  TODO: SUBROUTINE .next /* FWSIZE */
//  TODO: SUBROUTINE .fasm "[\x27]", LIT, _, r0, "ldr r0, [data_space], #4" /* FWSIZE */

.fasm1 "(BRANCH)",BRANCH, _, "ldr r0, [next_inst]"
add next_inst, next_inst, r0 /* FWSIZE */
.next
.fasm1 "(?BRANCH)", ZBRANCH, r1, "ldr r0, [next_inst]"
cmp r1, #0
addeq next_inst, next_inst, r0
addne next_inst, #4
.next /* FWSIZE */
.fasm "[\x27]", LIT, _, r0, "ldr r0, [next_inst], #4" /* FWSIZE */
.macro BRANCH, pos
  b .+\pos
.endm
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
.fasm "CELL-SIZE", CELL_SIZE, _, r0, "mov r0, #4" /* CELLSIZE */
.fasm "CHAR-SIZE", CHAR_SIZE, _, r0, "mov r0, #1" /* CHARSIZE */

.fasm "NIP", _, r0-r1, r0
.fasm "DROP", _, _, _, "add sp, #4" /* CELLSIZE */
.fasm "DUP", _, _, r0, "ldr r0, [sp]"
.fasm "OVER", _, _, r0, "ldr r0, [sp, #4]" /* CELLSIZE */
.fasm "PICK", _, r0, r0, "ldr r0, [sp, r0, LSL #2]" /* CELLSIZE */
.fasm "ROT", _, r0-r2, r2, "push {r0-r1}"
.fasm "SWAP", _, r0-r1, r1,"push {r0}"

.fasm "R\x40", R_FETCH, _, r0, "ldr r0, [rsp]" /* FWSIZE */
.fasm "R>", R_FROM, _, r0, "ldr r0, [rsp], #4" /* FWSIZE */
.fasm ">R", TO_R, r0, _, "str r0, [rsp, #-4]!" /* FWSIZE */
.fasm "DEPTH", _, _, r0, "rsb r0, sp, #0x8000", "lsr r0, #2" /* FWSIZE */
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

There are also a couple of variables we need, this goes into a
different file (~vars.s~), so that the ~previous_entry~ points to the
latest defined Forth word.

{{{cstart}}}
#+BEGIN_SRC asm :tangle vars.s
.data
.balign 4
HERE_LOC: .4byte DATA_END
.globl previous_entry
LATEST_LOC:   .4byte previous_entry
STATE_LOC:    .4byte 0
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

We also need to implement functions for input/output.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
.fasm "EMIT", _, r0, _, "b uart_putc"
.fasm "KEY", _, _, r0, "push {lr}", "bl uart_getc", "bl uart_putc", "pop {lr}"
.fasm "HEX.", HEX_PRINT, r0, _, "b puthex"
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

*** TODO Simple helper words<<sec:forth-assembly>>
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
/* TODO: Use this more liberally */
.macro .fdef1 name:req, label, imm, hidden, rest:vararg
  .entry \name, \label, \imm, \hidden
  .forth_interpreter
  .ifnb \rest ; .fw \rest ; .endif
.endm
.macro .fdef name:req, label, rest:vararg
  .fdef1 \name, \label, 0, 0, \rest
.endm
#+END_SRC
{{{cmid}}}
{{{cend}}}

#+BEGIN_SRC asm :tangle stage0.s
.fdef "1-", DECR, LIT, L,1, SUB, EXIT
.fdef "1+", INCR, LIT, L,1, ADD, EXIT
.fdef "2DUP", TWO_DUP, OVER, OVER, EXIT
.fdef "2DROP", TWO_DROP, DROP, DROP, EXIT
.fdef "-ROT", NROT, ROT, ROT, EXIT
.fdef "2>R", TWO_TO_R, R_FROM, NROT, SWAP
.fw TO_R, TO_R, TO_R, EXIT
.fdef "2R>", TWO_R_FROM, R_FROM, R_FROM
.fw R_FROM, ROT, TO_R, SWAP, EXIT
.fdef "2RDROP", TWO_R_DROP, R_FROM, R_FROM
.fw R_FROM, TWO_DROP, TO_R, EXIT
.fdef "2R\x40", TWO_R_FETCH, R_FROM
.fw TWO_R_FROM, TWO_DUP, TWO_TO_R, ROT
.fw TO_R, EXIT
.fdef "TRUE", _, LIT, L,-1, EXIT
.fdef "FALSE", _, LIT, L,0, EXIT
.fdef "HERE_VAR", _, LIT, L,HERE_LOC, EXIT
.fdef "LATEST", _, LIT, L,LATEST_LOC, EXIT
.fdef "STATE", _, LIT, L,STATE_LOC, EXIT
.fdef "HERE", _, HERE_VAR, FETCH, EXIT
.fdef "CHAR+", CHAR_ADD, CHAR_SIZE, ADD, EXIT
.fdef "CELL+", CELL_ADD, CELL_SIZE, ADD, EXIT
.fdef "CHARS", _, CHAR_SIZE, STAR, EXIT
.fdef "CELLS", _, CELL_SIZE, STAR, EXIT
.fdef "C\x2c", C_COMMA, HERE, C_STORE, HERE
.fw CHAR_ADD, HERE_VAR, STORE, EXIT
.fdef "\x2c", COMMA, HERE, STORE, HERE
.fw CELL_ADD, HERE_VAR, STORE, EXIT
#+END_SRC

*** TODO Creation
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "ALLOT", _
  .fw HERE, ADD, HERE_VAR, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: ALLOT HERE + HERE_VAR ! ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "ALIGN", _
  .fw HERE, CELL_SIZE, DECR, ADD
  .fw CELL_SIZE, DECR, INVERT, AND
  .fw HERE_VAR, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: ALIGN
  HERE cell-size 1- + cell-size 1-  invert and
  HERE_VAR ! ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "CREATE", _
  .fw ALIGN
  .fw HERE, LATEST, FETCH
  .fw COMMA, LATEST, STORE
  .fw LIT, L,0, C_COMMA
  .fw LIT, L,0, C_COMMA, ALIGN
  .fw BL, WORD
  .fw CELL_SIZE, ALLOT
  .fw FETCH, CHARS, ALLOT
  .fw LIT, L,0, C_COMMA
  .fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: CREATE ( "<spaces>name" -- )
  align
  here latest @ , latest !
  0 C, 0 C, align \ flags
  bl word \ c-str
  cell-size allot \ allot space for len
  @ chars allot \ allot len characters
  0 C, \ For C string compatibility
  align ; \ padding
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "BALIGN", BALIGN, DECR, SWAP, OVER
.fw ADD, SWAP, INVERT, AND, EXIT
.fdef "ENTRY-NEXT", ENTRY_NEXT, EXIT
.fdef "ENTRY-FLAGS", ENTRY_FLAGS, CELL_ADD, EXIT
.fdef "ENTRY-LEN", ENTRY_LEN, LIT, L,2
.fw CELLS, ADD, EXIT
.fdef "ENTRY-CHARS", ENTRY_CHARS, LIT, L,3
.fw CELLS, ADD, EXIT
.fdef "ENTRY-XT", ENTRY_XT, DUP
.fw ENTRY_LEN, FETCH, LIT, L,1, ADD, SWAP
.fw ENTRY_CHARS, ADD, LIT, L,4, BALIGN, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}



{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "HIDDEN?", HIDDENP
  .fw ENTRY_FLAGS, C_FETCH, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: HIDDEN? entry-flags C@ ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "IMMEDIATE?", IMMEDIATEP
  .fw ENTRY_FLAGS, CHAR_ADD, C_FETCH, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: IMMEDIATE? ( xt -- -1|0 )
  entry-flags char+ C@ ;
#+END_SRC
{{{cend}}}

Toggles hidden status of a given xt

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "HIDE", _, CELL_ADD, DUP, C_FETCH
  .fw INVERT, SWAP, C_STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: HIDE ( xt -- )
  cell+ dup C@
  invert swap C! ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef1 "IMMEDIATE", _, -1 /* immediate */
  .fw LATEST, FETCH
  .fw TRUE, SWAP, CELL_ADD, CHAR_ADD, C_STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: IMMEDIATE ( -- )
  LATEST @
  true swap cell+ char+ C!
#+END_SRC
{{{cend}}}

*** TODO Lookup
- TODO :: Explain "c-addr u" and fwsize


{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "FIND\x27", FIND_NEW
  .fw LATEST, FETCH
FIND_LOOP: /* ( c-addr u entry ) */
  .fw DUP, LIT, L,0, EQUAL, ZBRANCH, L,(FIND_NON_END-.)
  .fw DROP, DROP, LIT, L,0, EXIT
FIND_NON_END:
  .fw DUP, HIDDENP, INVERT
  .fw ZBRANCH, L,(FIND_NEXT_ENTRY-.)

  .fw TWO_DUP, ENTRY_LEN, FETCH, EQUAL
  .fw ZBRANCH, L,(FIND_NEXT_ENTRY-.)
  /* c-addr u entry */
  .fw TWO_DUP, ENTRY_CHARS
  .fw LIT, L,4, PICK
  /* c-addr u entry u entry-str c-addr */
  .fw MEMCMP, ZBRANCH, L,(FIND_NEXT_ENTRY-.)

  .fw NIP, NIP
  .fw DUP, ENTRY_XT
  .fw SWAP, IMMEDIATEP
  .fw ZBRANCH, L,(NON_IMM-.), LIT, L,1, BRANCH, L,(IMM_END-.)
NON_IMM:
  .fw LIT, L,-1
IMM_END:
  .fw EXIT

FIND_NEXT_ENTRY:
  .fw FETCH
  .fw BRANCH, L,(FIND_LOOP-.)
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: FIND' ( c-addr u -- c-addr 0 | xt 1 | xt -1 )
  latest @
  begin \ c-addr u entry
    dup 0 = if drop drop 0 exit then
    dup hidden? invert if
      2dup entry-len = if \ c-addr u entry entry-len u
        2dup entry-chars 4 pick
        \ c-addr u entry u entry-str c-addr
        memcmp if \ c-addr u entry
          nip nip \ entry
          dup entry-xt
          swap immediate? if 1 else -1 then
          exit
        then
      then
    then
    @ \ Fetch next entry
  again ;
#+END_SRC
{{{cend}}}

We also need to write the memory comparison, as well as the utilities
for the flags.

*** TODO Memory comparison
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "MEMCMP", _
  .fw ROT, LIT, L,0
  .fw TWO_TO_R
MEMCMP_LOOP:
  .fw TWO_DUP, R_FETCH, ADD, C_FETCH
  .fw SWAP, R_FETCH, ADD, C_FETCH

  .fw CHAR_EQUAL, INVERT, ZBRANCH, L,(MEMCMP_NEXT-.)
  .fw TWO_R_DROP, TWO_DROP, FALSE, EXIT
MEMCMP_NEXT:
  .fw R_FROM, LIT, L,1, ADD, TO_R
  .fw TWO_R_FETCH, EQUAL
  .fw ZBRANCH, L,(MEMCMP_LOOP-.)
  .fw TWO_R_DROP

  .fw TWO_DROP, TRUE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: MEMCMP ( len a b -- true | false )
  rot 0 do
    2dup i + C@ swap i + C@
    = invert if unloop 2drop false exit then
  loop
  2drop true ;
#+END_SRC
{{{cend}}}

** TODO Input
*** Words
TODO: backspace (or perhaps with a modified key?)

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s asm :tangle stage0.s
.fdef "LOWER", _
  .fw DUP, LIT, L,'A', U_LESS_THAN
  .fw OVER, LIT, L,'Z', U_GREATER_THAN
  .fw OR, INVERT, ZBRANCH, L,(1f-.)
  .fw LIT, L,32, ADD
1:.fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: LOWER ( char -- char )
  dup char A U< over char Z U>
  or invert if 32 + then ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "CHAR\x3d", CHAR_EQUAL
  .fw TWO_DUP, EQUAL, ZBRANCH, L,(1f-.)
  .fw TWO_DROP, TRUE, EXIT
1:.fw OVER, LIT, L,33, U_LESS_THAN
  .fw OVER, LIT, L,33, U_LESS_THAN
  .fw AND, ZBRANCH, L,(2f-.)
  .fw TWO_DROP, TRUE, EXIT
2:.fw LOWER, SWAP, LOWER, EQUAL
  .fw ZBRANCH, L,(3f-.)
  .fw TRUE, EXIT
3:.fw FALSE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: CHAR=' ( char char -- -1|0 )
  2dup = if 2drop true exit then
  over 33 U< over 33 U< and if 2drop true exit then
  lower swap lower = if true exit then
  false ;
#+END_SRC
{{{cend}}}

TODO: transient region

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "WORD\x27", WORD_NEW
  .fw HERE, SWAP, LIT, L,0
WORD_SKIP:
  .fw DROP, KEY, TWO_DUP, CHAR_EQUAL
  .fw INVERT, ZBRANCH, L,(WORD_SKIP-.)
WORD_LOOP:
  .fw DUP, C_COMMA, OVER, CHAR_EQUAL
  .fw ZBRANCH, L,(WORD_CONT-.)
  .fw DROP, CHAR_SIZE, NEGATE, ALLOT
  .fw HERE, OVER, SUB, LIT, L,0, C_COMMA
  .fw LIT, L,-1, OVER, SUB, ALLOT, EXIT
WORD_CONT:
  .fw KEY, BRANCH, L,(WORD_LOOP-.)
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: WORD' ( char "<chars>ccc<char>" -- c-addr u )
  here swap
  0 begin drop key 2dup char= until
  begin \ start char key
    dup C,
    over char= if \ start char
      drop char-size negate allot
      here over - 0 C,
      -1 over - allot exit
    then
    key
  again ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "WORD", WORD
  .fw HERE, SWAP, CELL_SIZE, ALLOT,
  .fw WORD_NEW, ROT, STORE
  .fw CELL_SIZE, NEGATE, ALLOT
  .fw CELL_SIZE, SUB, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: WORD ( char "<chars>ccc<char>" -- c-addr u )
  here swap cell-size allot
  word' rot \ c-addr u1 len-pos
  ! \ c-addr
  cell-size negate allot \ deallocate len
  cell-size - ; \ make addr point to len
#+END_SRC
{{{cend}}}

*** Numbers
If the character is less than '0', or between '9' and 'A' (or 'Z' and
'a'), then it underflows, and will end up being greater than BASE.

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "CHAR->DIGIT", CHAR_TO_DIGIT
  .fw LIT, L,'0', SUB
  .fw DUP, LIT, L,9, U_GREATER_THAN, ZBRANCH, L,(C_TO_D_END-.)
  .fw LIT, L,('A'-'9'-1), SUB
  .fw DUP, LIT, L,10, U_LESS_THAN, ZBRANCH, L,(C_TO_D_A-.)
  .fw LIT, L,10, SUB
C_TO_D_A:
  .fw DUP, LIT, L,35, U_GREATER_THAN, ZBRANCH, L,(C_TO_D_END-.)
  .fw LIT, L,32, SUB
  .fw DUP, LIT, L,10, U_LESS_THAN, ZBRANCH, L,(C_TO_D_END-.)
  .fw LIT, L,10, SUB
C_TO_D_END:
  .fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: CHAR->DIGIT ( char -- digit )
  char 0 -
  dup 9 U> if
    7 - \ 9 : ; < = > ? @ A
    dup 10 U< if 10 - then
    dup 35 U> if
      32 - \ A-Z [ \ ] ^ _ ` a-z
      dup 10 U< if 10 - then
    then
  then ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.data
BASE_LOC: .cell 10
.text
.fdef "BASE", BASE
  .fw LIT, L,BASE_LOC, EXIT
.fdef "DECIMAL", DECIMAL
  .fw LIT, L,10, BASE, STORE, EXIT
.fdef ">NUMBER", TO_NUMBER
  .fw OVER, ADD, DUP, TO_R, SWAP
  .fw TWO_TO_R
TO_NUM_LOOP:
  .fw R_FETCH, C_FETCH, CHAR_TO_DIGIT, DUP
  .fw BASE, FETCH, U_LESS_THAN
  .fw ZBRANCH, L,(TO_NUM_ELSE-.)
  .fw SWAP, BASE, FETCH, STAR, ADD
  .fw BRANCH, L,(TO_NUM_NEXT-.)
TO_NUM_ELSE:
  .fw DROP, R_FETCH, TWO_R_DROP, R_FROM
  .fw OVER, SUB,  EXIT
TO_NUM_NEXT:
  .fw R_FROM, LIT, L,1, ADD, TO_R
  .fw TWO_R_FETCH, EQUAL
  .fw ZBRANCH, L,(TO_NUM_LOOP-.)
  .fw TWO_R_DROP
  .fw R_FROM, LIT, L,0
  .fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
variable BASE 10 BASE !
: >NUMBER ( ud1 c-addr1 u1 -- ud2 c-addr2 u2 )
  over + dup >R swap \ ud1 c-addr1+u1 c-addr1; R: c-addr1+u1
  do \ ud1; loops with  c-addr1 <= I < c-addr1+u1
    I C@ char->digit dup BASE @ U< if \ ud1 digit
      swap BASE @ * +
    else \ ud2 digit
      drop I unloop R> over - exit \ ud2 c-addr2 u2
    then
  loop
  R> 0 ;
#+END_SRC
{{{cend}}}

(We also need a way of converting signed numbers, and numbers in other
bases too, according to ยง3.4.1.3.

#+BEGIN_SRC forth
: NUMBER ( ud1 c-addr u1 -- number c-addr u2 )
  BASE @ >R
  over @ ''' = if parse-char then
  over @ case
    '#' of 1 + decimal endof
    '$' of 1 + hex endof
    '%' of 1 + binary endof
  endcase
  dup 0 = if 1+ swap 1- exit ( to indicate that we failed to parse ) then
  over @ '-' = >R
  R@ if 1+ then
  dup 0 = if 1+ swap -1 exit ( to indicate that we failed to parse ) then
  >number
  rot R> if negate then -rot
  R> BASE !
  ;

: PARSE-CHAR ( ud1 c-addr u1 -- ud2 c-addr u2 )
  dup 3 = if
    drop 1+ dup C@ rot + swap 2 + 0
  then
  ;
#+END_SRC

** TODO Interpreting
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0-machine-arm.s
// TODO: This is indirect at the moment
.fasm1 "EXECUTE", EXECUTE, r0
  .execute
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
:ASM EXECUTE-INTERPRETER
  { r0 } value_stack POP
  r1 r0 4 LDR+ \ TODO
  r0 BX ;
#+END_SRC
{{{cend}}}

** TODO Compiling
See ยง3.4 of the [[https://www.taygeta.com/forth/dpans3.htm#3.4][ANSI Forth manual]].

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "BL", BL
  .fw LIT, L,' ', EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: BL ( -- char ) 32 ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "\x27", TICK
  .fw BL, WORD_NEW, FIND_NEW, DROP, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: TICK ( "<spaces>name" -- xt )
  bl word' find' drop ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "OK", OK
  .fw LIT, L,'O', EMIT, LIT, L,'k'
  .fw EMIT, BL, EMIT, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: OK
  bl emit char O emit char k emit bl emit ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "ERROR", ERROR
  .fw LIT, L,'E', EMIT, LIT, L,'r', EMIT
  .fw LIT, L,'r', EMIT, BL, EMIT, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: ERROR
  char E emit char r emit char r emit bl emit ;
#+END_SRC
{{{cend}}}

** TODO REPL
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
// TODO: Different interpretation modes
.fdef "COMPILE\x2c", COMPILE_COMMA
  .fw COMMA, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "QUIT-FOUND", QUIT_FOUND
  .fw NIP, LIT, L,-1, EQUAL, STATE
  .fw FETCH, AND, ZBRANCH, L,(Q_F_EX-.)
  .fw COMPILE_COMMA, BRANCH, L,(Q_F_END-.)
Q_F_EX:
  .fw EXECUTE
Q_F_END:
  .fw OK, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: QUIT_FOUND ( xt u -1|1 -- )
  nip -1 = state @ and if \ Compiling
    compiling, else execute then
  ok ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef1 "LITERAL", LITERAL, -1 /* immediate */
  .fw LIT, LIT, COMMA
  .fw COMMA, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: LITERAL ( x -- )
  ' lit compiling, , ; \ TODO
: LITERAL ['] lit , ; IMMEDIATE
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "QUIT-NOT-FOUND", QUIT_NOT_FOUND
  .fw NROT, TO_NUMBER, LIT, L,0 // TODO: http://forth-standard.org/standard/usage#subsection.3.4.1.3
  .fw EQUAL, ZBRANCH, L,(Q_N_F_ELSE-.)
  .fw DROP, STATE, FETCH, ZBRANCH, L,(Q_N_F_END-.)
  .fw LITERAL
  .fw BRANCH, L,(Q_N_F_END-.)
Q_N_F_ELSE:
  .fw TWO_DROP, ERROR, EXIT
Q_N_F_END:
  .fw OK, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: QUIT_NOT_FOUND ( c-addr u 0 -- )
  rot rot >number 0 = if \ TODO negative numbers
    drop state @ if \ Compiling
      literal
    then
  else
    2drop error exit
  then
  ok ;
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "QUIT", QUIT
QUIT_LOOP:
  .fw BL, WORD_NEW, DUP, NROT
  .fw FIND_NEW, ROT, SWAP
  .fw DUP, ZBRANCH, L,(QUIT_N_F-.)
  .fw QUIT_FOUND, BRANCH, L,(QUIT_LOOP-.)
QUIT_N_F:
  .fw QUIT_NOT_FOUND, BRANCH, L,(QUIT_LOOP-.)
  .fw EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: QUIT ( -- )
  \ TODO: Set up value and return stacks
  begin
    bl word' dup rot rot \ u c-addr u
    find' rot swap \ c-addr u -1|0|1
    dup if quit_found else
          quit_not_found then
    ok
  again ;
#+END_SRC
{{{cend}}}

** TODO DOES>
** TODO Brave New Words
{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef1 "[", LBRAC,-1 /* immediate */
  .fw LIT, L,0, STATE, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: [ false state ! IMMEDIATE
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef "]", RBRAC
  .fw LIT, L,-1, STATE, STORE, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
: ] true state !
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
// TODO: SUBROUTINE .fdef "\x3a", COLON
// TODO: SUBROUTINE   .fw CREATE
// TODO: SUBROUTINE   .fw LIT, forth_interpreter, COMMA
// TODO: SUBROUTINE   .fw LATEST, FETCH, HIDE
// TODO: SUBROUTINE   .fw RBRAC, EXIT
.fdef "\x3a", COLON
  .fw CREATE
  .fw LATEST, FETCH, HIDE
  .fw RBRAC, EXIT
  # TODO
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
#+END_SRC
{{{cend}}}

{{{cstart}}}
#+BEGIN_SRC asm :tangle stage0.s
.fdef1 "\x3b", SEMICOLON, -1 /* immediate */
  .fw LIT, L,EXIT, COMMA
  .fw LATEST, FETCH, HIDE, LBRAC, EXIT
#+END_SRC
{{{cmid}}}
#+BEGIN_SRC forth
TODO
#+END_SRC
{{{cend}}}

** TODO Control Words
TODO explain, especially as we don't have comments yet
- Note, not using compile, for [']
- Note, literal defined previously
  - But ['] and LITERAL are very similar
    - Can we use LIT as ['], it only needs compilation semantics?
      - Not quite, it doesn't push XT, it pushes entry->interpreter
        - Perhaps swap the meaning of XT back?
#+BEGIN_SRC forth
: POSTPONE ' compile, ; IMMEDIATE \ Can place elsewhere TODO
#+END_SRC

#+BEGIN_SRC forth
: ['] lit lit , ' , ; IMMEDIATE
: IF
  ['] BRANCH, compile,
  HERE 0 , ; IMMEDIATE
: THEN
  HERE over - swap ! ; IMMEDIATE
: ELSE
  [']BRANCH, compile,
  HERE swap 0 ,
  HERE over - swap ! ; IMMEDIATE
#+END_SRC

#+BEGIN_SRC forth
TODO TO TEST

: BEGIN
  HERE ; IMMEDIATE
: AGAIN
  [']BRANCH, compile,
  HERE - , ; IMMEDIATE
: UNTIL
  ['] BRANCH, compile,
  HERE - , ; IMMEDIATE
: WHILE
  ['] BRANCH, compile,
  HERE swap 0 , ; IMMEDIATE
: REPEAT
  [']BRANCH, ,
  HERE swap - ,
  HERE over swap - swap ! ; IMMEDIATE
#+END_SRC

#+BEGIN_SRC forth
: DO
  2>R ; IMMEDIATE
: ?DO
  2dup <> ['] BRANCH, compile, HERE
  2>R ; IMMEDIATE
: LOOP
  ;
: +LOOP
  ;
: LEAVE
  TODO ; IMMEDIATE
#+END_SRC

** TODO Comments
#+BEGIN_SRC forth
: CHAR word' drop C@ ;
: [CHAR] char literal ; IMMEDIATE
#+END_SRC

#+BEGIN_SRC forth
: \ begin key 10 = until ;
: ( begin key [char] ) = until ;
#+END_SRC

* TODO Change
http://forth-standard.org/standard/doc
- Have a 'non-standard' but simpler Forth?
- Forth requires max 31 chars for defn names, so we can simplify the dict
- Document sec 4.1
- Exns for ambiguous conds?
* TODO Testing
- ~SOURCE-ID~
* TODO After REPL

* TODO Forth Assembler
** ;CODE
* TODO Ideas
- Server and client :: Have the C implementation be a REPL server,
     with separate messages, errors, and stack buffers?
  - Support for up/downloading 'images' (the dictionary?), and
    perhaps replace raspbootin?
- DMA Forth :: Do [[cite:runDMA][run-DMA] TODO this link
- [[Naming][Naming]] :: All the stack manipulation could be simplified by having
            names.
- [[PRF][Partial Recursive Functions (PRF)]] :: Perhaps could take inspiration
     from the way composition is implemented there, in order to avoid
     all the stack manipulation? This could be more in the Forth
     spirit than [[Naming][naming]].
- Dereference-count :: When a pointer gets dereferenced a lot, move
     its pointee closer to that pointer (when doing mark&move GC)? To
     make it more likely to be in the cache (akin to
     simulated-annealing in the connection machine).
- Simple JIT :: Inline all the non-recursive calls?
- Debugger :: Breakpoints and tracing?
- Exception aspects :: To decouple the 'textbook algorithm' from exception handling?
- SD Card read/store :: So that we can compile to/read from disk, and don't have to
- Memory management :: Simple bump allocator + GC? Might have to
     modify @ and ! for GC?

* TODO Naming
Plan is to extend forth to do naming, to make programs easier to
understand.

Doing this naively will probably result in a dynamic environment.

Something like
#+BEGIN_SRC forth
:fun REV-SUB ARG1 ARG2 => ARG2 ARG1 - ;
#+END_SRC
which could get turned into the equivalent of
#+BEGIN_SRC forth
: REV-SUB
  2 PUSH-STACK-FRAME
  2 FROM-FRAME
  1 FROM-FRAME
  -
  POP-FRAME
  ;
#+END_SRC
Also, I wonder if we need to redefine EXIT, for premature exits, or
perhaps have a trampoline take care of the push&pop, like so:
#+BEGIN_SRC asm
.fw SETUP
.fw P
.fw TEARDOWN
.fw EXIT
P:.fw BODY, ...
#+END_SRC

This might even lead to optimisations, e.g. to
#+BEGIN_SRC forth
: REV-SUB
  SWAP -
  ;
#+END_SRC

And arg-count checking, possibly only at runtime first, to make sure
we don't return multiple values or get too few arguments. Possibly
static-checking too?

* TODO Partial Recursive Functions (PRF) <<PRF>>
Perhaps turn something like
#+BEGIN_SRC forth
\ FOO ( A B C -- V W )
\ BAR ( E F -- X )
\ BAZ ( V W X -- M N O )
{ FOO , , BAR } BAZ
#+END_SRC
into
#+BEGIN_SRC forth
FOO >R
>R \ from the empty
BAR >R
R> R> R>
BAZ
#+END_SRC
* TODO Terminal on host with simple-forth.c?
First, define a protocol
- 0 n char0 ... charn ( send n chars )
- ?
* COMMENT Table column
#+BEGIN_EXPORT html
<script type="text/javascript">
  function openTab(event) {
    let open_index = 0;
    for (let el of event.target.parentElement.children) {
      if (el === event.target)
        break;
      ++open_index;
    }
    let table = event.target.
        parentElement.parentElement.parentElement;
    for (let tbody of table.getElementsByTagName("tbody")) {
      for (let row of tbody.children) {
        let index = 0;
        for (let data of row.children) {
          if (index == open_index) {
            for (element of data.children)
              element.style.display =
                  element.style.display === "none" ?
                  "block" : "none";
          }
          ++index;
        }
      }
    }
  }

  for (let element of document.getElementsByClassName("harmonica-table")) {
    for (let theads of element.getElementsByTagName("thead")) {
      for (let row of theads.children) {
        let index = 0;
        for (let data of row.children) {
          data.addEventListener(
            "click", openTab);
        }
        ++index;
      }
    }
  }
</script>
#+END_EXPORT


* Bibliography
#+BIBLIOGRAHPY: pi-bootstrap plain
